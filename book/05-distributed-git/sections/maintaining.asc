=== Bir Projeyi Yürütme

(((maintaining a project)))
Projeye katkı sağlamanın yanı sıra genellikle bilmeniz gereken bir diğer beceri de Bir projeyi etkili bir şekilde yürütmektir. 
Bu  `format-patch` ile oluşturulan ve size e-posta yoluyla gönderilen yamaları kabul etmek ve uygulamak veya eklediğiniz uzak dallardaki değişiklikleri projenize birleştirmekten oluşabilir. 
İster klasik bir repoyu yürütüyor olun, ister yamaları doğrulayarak veya onaylayarak projeye yardımcı olun; diğer katkıda bulunanlar için en açık ve sizin için uzun vadede en sürdürülebilir kabul yöntemini bilmeniz gerekir.

==== Tematik Dallarda Çalışma

(((branches, topic)))
Yeni bir çalışmayı birleştirmeyi düşündüğünüzde, sırf bunu denemek için geçici bir _tematik dal_ oluşturmak iyi bir fikirdir.
Bu şekilde, bir yamanın detaylarını bireysel olarak ayarlamak ve işe yaramıyorsa daha sonra geri dönmek üzere bir kenara ayırmak için zamanınız olur. 
Denemeyi yapacağınız işin konusuna dayanan basit ve açıklayıcı bir dal adı oluşturursanız (ör. `ruby_client` vb); bir süre terk edip daha sonra geri dönmek zorunda kalırsanız, kolaylıkla hatırlayabilirsiniz. 

Git projesinin yürütücüsü de genellikle bu dalları isimlendirir (ör. `sc/ruby_client`. Surada `sc` çalışmayı ekleyen kişinin kısaltmasıdır). 
Hatırlayacağınız gibi, bunu `master` dalınızdan şu şekilde oluşturabilirsiniz:

[source,console]
----
$ git branch sc/ruby_client master
----

Veya doğrudan o dala geçmek istiyorsanız, `checkout -b` seçeneğini kullanabilirsiniz:

[source,console]
----
$ git checkout -b sc/ruby_client master
----

Şimdi aldığınız çalışmayı bu tematik dala eklemeye hazırsınız ve onu daha uzun vadeli dallarınıza birleştirip birleştirmeyeceğinize karar verebilirsiniz.

[[_patches_from_email]]
==== E-Postadan gelen Yamaları Uygulamak

(((email, applying patches from)))
E-posta yoluyla alınan bir yamayı projenize birleştirmeniz gerekiyorsa, yamayı test etmek için tematik dalınıza uygulamanız gerekir.
E-postayla gönderilen bir yamayı uygulamanın iki yolu vardır: `git apply` ve `git am`.

===== Bir Yamayı `apply` ile Uygulamak

(((git commands, apply)))
Eğer birisi yamayı `git diff` veya Unix'un `diff` komutunun bir türevi ile oluşturduysa (ki bir sonraki bölümde göreceğiniz üzere bu önerilmez), yamayı `git apply` komutu ile uygulayabilirsiniz.
Yamayı `/tmp/patch-ruby-client.patch` dosyasına kaydettiğinizi farzedersek, şu şekilde uygulayabilirsiniz:

[source,console]
----
$ git apply /tmp/patch-ruby-client.patch
----

Bu, çalışma dizininizdeki dosyaları değiştirir.
Bir yama uygulamak için `patch -p1` komutunu çalıştırmakla neredeyse aynıdır; ancak daha paranoiddir ve patch'e göre daha az belirsiz eşleşme (fuzzy match) kabul eder.
Ayrıca, `git diff` formatında açıklanmış dosya ekleme, silme ve yeniden adlandırma işlemlerini, `patch` 'in yapmayacağı şekilde ele alır.
Son olarak, `git apply` uygulamanızda "tümünü uygula" veya "hiçbirini uygulama" kararını vermeniz gereken bir modelidir: `patch` ise yamaları kısmen uygulayabilir ve çalışma dizenizi tuhaf bir durumda bırakabilir.
`git apply` genel olarak `patch` 'den çok daha katı davranır.
Size bir katkı kaydı oluşturmaz: çalıştırdıktan sonra, değişiklikleri elle aşamalandırmanız ve katkı işlemeniz gerekir.

`git apply` komutunu, bir yamayı gerçekten uygulamadan önce, düzgün bir şekilde uygulanıp uygulanamayacağını kontrol etmek için de kullanabilirsiniz. 
Bunun için `git apply --check` komutu yamayla birlikte çalıştırabilirsiniz. 

[source,console]
----
$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
----

Eğer çıktı yoksa, yama temiz bir şekilde uygulanabilir demektir. 
Bu komut ayrıca, kontrolün başarısız olduğu durumlarda da sonucu sıfır olmayan bir durumla (non-zero status) çıkar, bu nedenle isterseniz bu komutu betiklerde de kullanabilirsiniz.

[[_git_am]]
===== `git am` Komutuyla Yama Uygulama

(((git commands, am)))
Eğer geliştirici yamasını oluşturmak için `format-patch` komutunu kullanacak tecrübede bir Git kullanıcısıysa; yama yazar bilgisi ve bir katkı mesajı da içereceği için, işiniz daha kolay olur.
Mümkünse, geliştiricilerinizi yamalarını oluşturmak için `diff` yerine `format-patch` kullanmaları yönünde teşvik edin.
Yalnızca eski yamalar (legacy patch) ve benzeri durumlar için `git apply` kullanmanız gerekir.

`format-patch` ile oluşturulan bir yamayı uygulamak için `git am` ("bir posta kutusundan bir dizi yamayı uygulamak" için bu komut kullanıldığından `am` olarak adlandırılır) kullanılır.
`git am` komutu teknik olarak, bir veya daha fazla e-posta mesajını tek bir metin dosyasında depolamak için oluşturulan basit bir düz-metin biçimi olan "mbox" dosyasını okumak amacıyla oluşturulmuştur.
Ve şuna benzer:


[source,console]
----
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith <jessica@example.com>
Date: Sun, 6 Apr 2008 10:17:23 -0700
Subject: [PATCH 1/2] add limit to log function

Limit log functionality to the first 20
----

Bu, önceki bölümde gördüğünüz `git format-patch` komutunun çıktısının başlangıcıdır; aynı zamanda geçerli bir mbox e-posta biçimini temsil eder.
Eğer biri size yamayı `git send-email` komutunu kullanarak düzgün şekilde e-posta ile gönderdiyse; ve siz de bunu mbox biçiminde indirir ve `git am` 'i o mbox dosyasına işaret edecek şekilde ayarlarsanız; gördüğü tüm yamaları uygulamaya başlayacaktır.
Eğer bir mbox formatında birkaç e-postayı kaydedebilen bir posta istemcisi çalıştırıyorsanız, tüm yama serilerini bir dosyaya kaydedip, bunların hepsini tek seferde uygulamak için `git am` 'i kullanabilirsiniz.

Ancak, birisi `git format-patch` kullanarak oluşturulan bir yama dosyasını bir bilet sistemi veya benzer bir yere yüklediyse; bu dosyayı yerel olarak kaydedip, ardından diskte kaydedilen bu dosyayı uygulamak için `git am` 'e iletebilirsiniz:

[source,console]
----
$ git am 0001-limit-log-function.patch
Applying: add limit to log function
----

Gördüğünüz gibi, temiz bir şekilde uygulandı ve otomatik olarak yeni bir katkı oluşturuldu. 
Yazar bilgileri, e-postanın `From` (gönderici) ve `Date` (tarih) başlıklarından; katkı mesajı, e-postanın `Subject` (konu) ve yamadan önceki gövde kısmından alınır. 
Örneğin, yukarıdaki mbox örneğinden uyarlanan bir yama için oluşturulan katkı şöyle görünecektir:

[source,console]
----
$ git log --pretty=fuller -1
commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
Author:     Jessica Smith <jessica@example.com>
AuthorDate: Sun Apr 6 10:17:23 2008 -0700
Commit:     Scott Chacon <schacon@gmail.com>
CommitDate: Thu Apr 9 09:19:06 2009 -0700

   add limit to log function

   Limit log functionality to the first 20
----

`Commit` (katkı) bilgileri yamayı uygulayan kişiyi ve uygulanma zamanını gösterir.
`Author` (yazar) bilgileri ise özgün yamayı oluşturan kişiyi ve ne zaman oluşturduğunu gösterir.

Ama yamanın temiz bir şekilde uygulanamaması ihtimal dahilindedir.
Belki ana dalınız, yamanın oluşturulduğu daldan çok uzaklaşmıştır veya yama henüz uygulamadığınız başka bir yamaya bağlıdır.
Bu durumda, `git am` işlemi başarısız olacak ve ne yapmak istediğinizi size soracaktır:

[source,console]
----
$ git am 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Patch failed at 0001.
When you have resolved this problem run "git am --resolved".
If you would prefer to skip this patch, instead run "git am --skip".
To restore the original branch and stop patching run "git am --abort".
----

Bu komut, sorun yaşadığı dosyalara "çatışan birleştirme" veya "yeniden temelleme işlemi" gibi çatışma işaretçileri koyar.
Bu sorunu çözmenin yolu neredeyse aynıdır: dosyayı çatışmayı çözecek şekilde düzenleyin, yeni dosyayı hazırlayın ve ardından bir sonraki yamaya devam etmek için `git am --resolved` komutunu çalıştırın:

[source,console]
----
$ (fix the file)
$ git add ticgit.gemspec
$ git am --resolved
Applying: seeing if this helps the gem
----

Eğer Git'in çatışmayı biraz daha akıllıca çözmesini istiyorsanız `-3` seçeneğini kullanarak, Git'in üç yollu bir birleştirme yapmayı denemesini sağlarsınız.
Yama üzerindeki işlenecek olan katkı, sizin reposunuzda bulunmuyorsa çalışmayacağı için, bu seçenek varsayılan olarak etkinleştirilmemiştir.
Eğer o katkı sizin reposunuzda mevcutsa (eğer yama bir halka açık katkıya dayanıyorsa), o zaman `-3` seçeneği genellikle bir çatışmalı yamanın uygulanması konusunda daha akıllıdır:

[source,console]
----
$ git am -3 0001-seeing-if-this-helps-the-gem.patch
Applying: seeing if this helps the gem
error: patch failed: ticgit.gemspec:1
error: ticgit.gemspec: patch does not apply
Using index info to reconstruct a base tree...
Falling back to patching base and 3-way merge...
No changes -- Patch already applied.
----

Yukarıdaki durumda `-3` seçeneği olmasaydı, yama bir çatışma olarak kabul edilirdi.
`-3` seçeneği kullanıldığı için temiz bir şekilde uygulandı.

Eğer bir mbox'tan bir dizi yama uyguluyorsanız; her bulduğu yamada durup, onu uygulamak isteyip istemediğinizi soran, etkileşimli `am` komutunu da çalıştırabilirsiniz:

[source,console]
----
$ git am -3 -i mbox
Commit Body is:
--------------------------
seeing if this helps the gem
--------------------------
Apply? [y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all
----

Eğer kaydedilmiş birkaç yamanız varsa ve hangilerini zaten uyguladığınızı veya uygulayacağınızı hatırlayamıyorsanız; öncesinde yamayı görmenize olanak sağladığı için, bu özellik oldukça kullanışlıdır.

Bir tema için tüm yamalar uygulandığında ve dalınıza katkı olarak işlendiğinde, bunları uzun vadeli çalışan bir dala birleştirip birleştirmeyeceğinizi veya nasıl birleştireceğinizi seçebilirsiniz.

[[_checking_out_remotes]]
==== Uzak Dallara Geçmek

(((branches, remote)))

Eğer bu katkı; kendi reposunu kuran, bir dizi değişiklik yapıp, buraya iten ve ardından değişikliklerin URL'sini ve değişikliklerin bulunduğu uzak dalın adını size gönderen bir Git kullanıcısından geldiyse, onları bir uzak repo olarak ekleyebilir ve yerel olarak birleştirebilirsiniz.

Örneğin, Jessica size kendi reposunun `ruby-client` dalında harika bir yeni özellik olduğunu söyleyen bir e-posta gönderirse; onun uzak reposunu ekleyip, bu yerelde dala geçiş yaparak, bu özelliği test edebilirsiniz:

[source,console]
----
$ git remote add jessica git://github.com/jessica/myproject.git
$ git fetch jessica
$ git checkout -b rubyclient jessica/ruby-client
----

Daha sonra, size başka bir harika özelliğe sahip başka bir dalı içeren yeni bir e-posta gönderirse, zaten uzak sunucuyu kurduğunuz için doğrudan `fetch` ve `checkout` yapabilirsiniz.

Biriyle sürekli birlikte çalışıyorsanız en kullanışlı olan yöntem budur. 
Eğer birisi arada bir ve sadece tek bir yama eklemek istiyorsa, o zaman bu değişiklikleri e-posta yoluyla kabul etmek, herkesin kendi sunucusunu çalıştırmasından ve birkaç yama almak için sürekli olarak uzak sunucular ekleyip, kaldırmasından daha tasarruflu bir zaman yönetimidir. 
Ayrıca, muhtemelen yalnızca bir veya iki yama sağlayan herkes için yüzlerce uzak sunucu eklemek istemezsiniz. 
Her ne kadar, betikler ve barındırılan hizmetler bu işi kolaylaştırabilse de, bu büyük ölçüde sizin ve katkı sağlayan geliştiricilerin nasıl geliştirme yaptığına bağlıdır.

Bu yaklaşımın bir diğer avantajı ise geçmişini de almanızdır. 
Geçerli birleştirme sorunlarına sahip olabilseniz dahi, bu çalışmalarının geçmişinizde nerede olduğunu bilirsiniz. 
Varsayılan olarak sağlanan düzgün bir üç yollu birleştirme, `-3` sağlamak zorunda kalmaktan ve yamanın erişiminiz olan herkese açık bir katkıya dayanmasını ummaktan iyidir.

Eğer sürekli olarak bir kişiyle çalışmıyor ama yine de yamayı onlardan bu şekilde çekmek istiyorsanız, `git pull` komutuna uzak repo URL'sini girebilirsiniz. 
Bu, tek seferlik bir çekme işlemi yapar ama URL'yi uzak bir referans olarak kaydetmez:

[source,console]
----
$ git pull https://github.com/onetimeguy/project
From https://github.com/onetimeguy/project
 * branch            HEAD       -> FETCH_HEAD
Merge made by the 'recursive' strategy.
----

[[_what_is_introduced]]
==== Katkıları Tanımlamak

(((branches, diffing)))
Şimdi, üzerinde katkı yapılan bir tematik dalınız var. 
Bu noktada, onunla ne yapmak istediğinizi belirleyebilirsiniz. 
Bu bölümde, ana dalınıza bir yamayı birleştirdiğinizde, tam olarak neyi tanıtacağınızı incelemek için birkaç komutu tekrar ele alacağız.

Tematik dalda olan, ancak ana dalınızda olmayan tüm katkıların gözden geçirilmesinde fayda vardır. 
Ana dalınızda bulunan katkıları bundan hariç tutmak için `--not` seçeneğini dal adının önüne ekleyebilirsiniz. 
Bu, daha önce kullandığımız `master..contrib` biçimiyle aynı işlemi yapar. 
Örneğin, katkılayıcınız size iki yama gönderirse ve siz `contrib` adında bir dal oluşturup bunları oraya uygularsanız, şunu çalıştırabilirsiniz:

[source,console]
----
$ git log contrib --not master
commit 5b6235bd297351589efc4d73316f0a68d484f118
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Oct 24 09:53:59 2008 -0700

    seeing if this helps the gem

commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
Author: Scott Chacon <schacon@gmail.com>
Date:   Mon Oct 22 19:38:36 2008 -0700

    updated the gemspec to hopefully work better
----

Hatırlayacağınız üzere her katkının hangi değişiklikleri içerdiğini görmek için, `git log` komutuna `-p` seçeneğini ekleyebilirsiniz. Ayrıca her katkıyla gelen fark da gösterilecektir.

Ana dal ve tematik dalı birleştirirseniz kodda ne gibi farklılıklar olacağının tam bir resmini görmek isterseniz, doğru sonuçları elde etmek için garip bir hile kullanmanız gerekebilir. 
Şunu çalıştırmayı düşünebilirsiniz:

[source,console]
----
$ git diff master
----

Bu komut size bir fark gösterir, ancak sonuç yanıltıcı olabilir. 
Eğer `master` dalınız, tematik dalınızı oluşturduğunuzdan bu yana ilerlemişse, çok garip sonuçlar elde edebilirsiniz. 
Bunun sebebi, Git'in üzerinde bulunduğunuz tema dalındaki son katkının pozuyla, `master` dalındaki son katkının pozunu doğrudan karşılaştırmasıdır. 
Örneğin, `master` dalındaki bir dosyaya bir satır eklerseniz; pozların doğrudan karşılaştırılması, tematik dalın bu satırı kaldıracakmış gibi görünmesine neden olur.

Eğer `master` dalı tematik dalınızın doğrudan bir atası ise, bu bir sorun değildir; ancak eğer iki geçmiş ayrıldıysa, fark `master` dalına özgü olan her şeyi kaldırıyor ve tema dalınızdaki tüm yeni şeyleri ekliyormuş gibi görünecektir.

Gerçekte görmek istediğiniz şey, konu dalına eklenen değişikliklerdir, yani bu dalı ana dala birleştirdiğinizde getireceğiniz çalışma.
Bunu görmek için, Git'in tema dalınızın son katkısını, master üzerindeki ilk ortak atasıyla karşılaştırması neticesinde görebilirsiniz.

Teknik olarak bunu yapmanın yolu: ortak atayı açıkça bulup ardından diff'i üzerinde çalıştırmaktır:

[source,console]
----
$ git merge-base contrib master
36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
$ git diff 36c7db
----

or, more concisely:

[source,console]
----
$ git diff $(git merge-base contrib master)
----

Yine de bunlar özellikle kullanışlı yöntemler değil, bu yüzden Git aynı işi yapmak için başka bir kısaltma sağlar: üç nokta sözdizimi.
`git diff` komutu bağlamında: `diff` yapmak için üzerinde bulunduğunuz dalın son katkısı ile başka bir dalın son ortak atası arasına üç nokta (...) koyabilirsiniz:

[source,console]
----
$ git diff master...contrib
----

Bu komut, mevcut tema dalınızın, master ile ortak atasından bu yana getirdiği çalışmayı gösterir.
Bu akılda tutmaya değer ve çok kullanışlı bir sözdizimidir.

==== Katkılanan İşi Birleştirmek

(((integrating work)))
Tema dalınızdaki tüm çalışma, ana dala daha yakın bir dala birleştirilmeye hazır olduğunda, sıradaki soru bunun nasıl yapılacağıdır.
Bunun da ötesinde, projenizi yürütmek için hangi genel iş akışını kullanmak istiyorsunuz?
Şimdi elinizdeki pek çok seçenekten birkaçını ele alacağız.

===== Merging Workflows

(((workflows, merging)))
One basic workflow is to simply merge all that work directly into your `master` branch.
In this scenario, you have a `master` branch that contains basically stable code.
When you have work in a topic branch that you think you've completed, or work that someone else has contributed and you've verified, you merge it into your master branch, delete that just-merged topic branch, and repeat.

For instance, if we have a repository with work in two branches named `ruby_client` and `php_client` that looks like <<merwf_a>>, and we merge `ruby_client` followed by `php_client`, your history will end up looking like <<merwf_b>>.

[[merwf_a]]
.History with several topic branches.
image::images/merging-workflows-1.png[History with several topic branches.]

[[merwf_b]]
.After a topic branch merge.
image::images/merging-workflows-2.png[After a topic branch merge.]

That is probably the simplest workflow, but it can possibly be problematic if you're dealing with larger or more stable projects where you want to be really careful about what you introduce.

If you have a more important project, you might want to use a two-phase merge cycle.
In this scenario, you have two long-running branches, `master` and `develop`, in which you determine that `master` is updated only when a very stable release is cut and all new code is integrated into the `develop` branch.
You regularly push both of these branches to the public repository.
Each time you have a new topic branch to merge in (<<merwf_c>>), you merge it into `develop` (<<merwf_d>>); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (<<merwf_e>>).

[[merwf_c]]
.Before a topic branch merge.
image::images/merging-workflows-3.png[Before a topic branch merge.]

[[merwf_d]]
.After a topic branch merge.
image::images/merging-workflows-4.png[After a topic branch merge.]

[[merwf_e]]
.After a project release.
image::images/merging-workflows-5.png[After a topic branch release.]

This way, when people clone your project's repository, they can either check out `master` to build the latest stable version and keep up to date on that easily, or they can check out `develop`, which is the more cutting-edge content.
You can also extend this concept by having an `integrate` branch where all the work is merged together.
Then, when the codebase on that branch is stable and passes tests, you merge it into a `develop` branch; and when that has proven itself stable for a while, you fast-forward your `master` branch.

===== Large-Merging Workflows

(((workflows, "merging (large)")))
The Git project has four long-running branches: `master`, `next`, and `pu` (proposed updates) for new work, and `maint` for maintenance backports.
When new work is introduced by contributors, it's collected into topic branches in the maintainer's repository in a manner similar to what we've described (see <<merwf_f>>).
At this point, the topics are evaluated to determine whether they're safe and ready for consumption or whether they need more work.
If they're safe, they're merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.

[[merwf_f]]
.Managing a complex series of parallel contributed topic branches.
image::images/large-merges-1.png[Managing a complex series of parallel contributed topic branches.]

If the topics still need work, they're merged into `pu` instead.
When it's determined that they're totally stable, the topics are re-merged into `master`.
The `next` and `pu` branches are then rebuilt from the `master`.
This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often:

.Merging contributed topic branches into long-term integration branches.
image::images/large-merges-2.png[Merging contributed topic branches into long-term integration branches.]

When a topic branch has finally been merged into `master`, it's removed from the repository.
The Git project also has a `maint` branch that is forked off from the last release to provide backported patches in case a maintenance release is required.
Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.
The Git project's workflow is specialized.
To clearly understand this you could check out the https://github.com/git/git/blob/master/Documentation/howto/maintain-git.txt[Git Maintainer's guide].

[[_rebase_cherry_pick]]
===== Rebasing and Cherry-Picking Workflows

(((workflows, rebasing and cherry-picking)))
Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history.
When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or `develop`, and so on) branch.
If that works well, you can fast-forward your `master` branch, and you'll end up with a linear project history.

(((git commands, cherry-pick)))
The other way to move introduced work from one branch to another is to cherry-pick it.
A cherry-pick in Git is like a rebase for a single commit.
It takes the patch that was introduced in a commit and tries to reapply it on the branch you're currently on.
This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you'd prefer to cherry-pick it rather than run rebase.
For example, suppose you have a project that looks like this:

.Example history before a cherry-pick.
image::images/rebasing-1.png[Example history before a cherry-pick.]

If you want to pull commit `e43a6` into your master branch, you can run

[source,console]
----
$ git cherry-pick e43a6
Finished one cherry-pick.
[master]: created a0a41a9: "More friendly message when locking the index fails."
 3 files changed, 17 insertions(+), 3 deletions(-)
----

This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different.
Now your history looks like this:

.History after cherry-picking a commit on a topic branch.
image::images/rebasing-2.png[History after cherry-picking a commit on a topic branch.]

Now you can remove your topic branch and drop the commits you didn't want to pull in.

===== Rerere

(((git commands, rerere)))(((rerere)))
If you're doing lots of merging and rebasing, or you're maintaining a long-lived topic branch, Git has a feature called ``rerere'' that can help.

Rerere stands for ``reuse recorded resolution'' -- it's a way of shortcutting manual conflict resolution.
When rerere is enabled, Git will keep a set of pre- and post-images from successful merges, and if it notices that there's a conflict that looks exactly like one you've already fixed, it'll just use the fix from last time, without bothering you with it.

This feature comes in two parts: a configuration setting and a command.
The configuration setting is `rerere.enabled`, and it's handy enough to put in your global config:

[source,console]
----
$ git config --global rerere.enabled true
----

Now, whenever you do a merge that resolves conflicts, the resolution will be recorded in the cache in case you need it in the future.

If you need to, you can interact with the rerere cache using the `git rerere` command.
When it's invoked alone, Git checks its database of resolutions and tries to find a match with any current merge conflicts and resolve them (although this is done automatically if `rerere.enabled` is set to `true`).
There are also subcommands to see what will be recorded, to erase specific resolution from the cache, and to clear the entire cache.
We will cover rerere in more detail in <<ch07-git-tools#ref_rerere>>.

[[_tagging_releases]]
==== Tagging Your Releases

(((tags)))(((tags, signing)))
When you've decided to cut a release, you'll probably want to assign a tag so you can re-create that release at any point going forward.
You can create a new tag as discussed in <<ch02-git-basics#ch02-git-basics>>.
If you decide to sign the tag as the maintainer, the tagging may look something like this:

[source,console]
----
$ git tag -s v1.5 -m 'my signed 1.5 tag'
You need a passphrase to unlock the secret key for
user: "Scott Chacon <schacon@gmail.com>"
1024-bit DSA key, ID F721C45A, created 2009-02-09
----

If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags.
The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content.
To do this, you can figure out which key you want by running `gpg --list-keys`:

[source,console]
----
$ gpg --list-keys
/Users/schacon/.gnupg/pubring.gpg
---------------------------------
pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
uid                  Scott Chacon <schacon@gmail.com>
sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]
----

Then, you can directly import the key into the Git database by exporting it and piping that through `git hash-object`, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:

[source,console]
----
$ gpg -a --export F721C45A | git hash-object -w --stdin
659ef797d181633c87ec71ac3f9ba29fe5775b92
----

Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the `hash-object` command gave you:

[source,console]
----
$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
----

If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared with everyone.
If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:

[source,console]
----
$ git show maintainer-pgp-pub | gpg --import
----

They can use that key to verify all your signed tags.
Also, if you include instructions in the tag message, running `git show <tag>` will let you give the end user more specific instructions about tag verification.

[[_build_number]]
==== Generating a Build Number

(((build numbers)))(((git commands, describe)))
Because Git doesn't have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.
In response, Git generates a string consisting of the name of the most recent tag earlier than that commit, followed by the number of commits since that tag, followed finally by a partial SHA-1 value of the commit being described (prefixed with the letter "g" meaning Git):

[source,console]
----
$ git describe master
v1.6.2-rc1-20-g8c5b85c
----

This way, you can export a snapshot or build and name it something understandable to people.
In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this.
If you're describing a commit that you have directly tagged, it gives you simply the tag name.

By default, the `git describe` command requires annotated tags (tags created with the `-a` or `-s` flag); if you want to take advantage of lightweight (non-annotated) tags as well, add the `--tags` option to the command.
You can also use this string as the target of a `git checkout` or `git show` command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.
For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.

[[_preparing_release]]
==== Preparing a Release

(((releasing)))(((git commands, archive)))
Now you want to release a build.
One of the things you'll want to do is create an archive of the latest snapshot of your code for those poor souls who don't use Git.
The command to do this is `git archive`:

[source,console]
----
$ git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
$ ls *.tar.gz
v1.6.2-rc1-20-g8c5b85c.tar.gz
----

If someone opens that tarball, they get the latest snapshot of your project under a project directory.
You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:

[source,console]
----
$ git archive master --prefix='project/' --format=zip > `git describe master`.zip
----

You now have a nice tarball and a zip archive of your project release that you can upload to your website or email to people.

[[_the_shortlog]]
==== The Shortlog

(((git commands, shortlog)))
It's time to email your mailing list of people who want to know what's happening in your project.
A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or email is to use the `git shortlog` command.
It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:

[source,console]
----
$ git shortlog --no-merges master --not v1.0.1
Chris Wanstrath (6):
      Add support for annotated tags to Grit::Tag
      Add packed-refs annotated tag support.
      Add Grit::Commit#to_patch
      Update version and History.txt
      Remove stray `puts`
      Make ls_tree ignore nils

Tom Preston-Werner (4):
      fix dates in history
      dynamic version method
      Version bump to 1.0.2
      Regenerated gemspec for version 1.0.2
----

You get a clean summary of all the commits since v1.0.1, grouped by author, that you can email to your list.
