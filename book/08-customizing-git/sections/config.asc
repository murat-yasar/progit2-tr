[[_git_config]]
=== Git Yapılandırması

(((git commands, config)))
<<ch01-introduction#ch01-introduction>> bölümünde kısaca okuduğunuz gibi, `git config` komutu ile Git yapılandırma ayarlarını belirleyebilirsiniz.
İlk yapmanız gereken şeylerden biri adınızı ve e-posta adresinizi ayarlamaktı.

[source,console]
----
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
----

Şimdi, Git kullanımınızı özelleştirmek için bu şekilde belirleyebileceğiniz daha ilginç seçeneklerden birkaçını öğreneceksiniz.

İlk olarak, hızlı bir gözden geçirme: Git, istediğiniz varsayılan olmayan davranışı belirlemek için bir dizi yapılandırma dosyası kullanır.
Git, bu değerleri aramak için ilk olarak sistem genelinde `/etc/gitconfig` dosyasına bakar; bu dosya, sistemdeki her kullanıcıya ve onların tüm repolarına uygulanan ayarları içerir.
`git config` komutuna `--system` seçeneğini eklerseniz, Git özellikle bu dosyadan okur ve buraya yazar.

Git'in bir sonraki baktığı yer, kullanıcıya özgü olan `~/.gitconfig` (ya da `~/.config/git/config`) dosyasıdır.
`--global` seçeneğini ekleyerek Git'in bu dosyayı okuyup yazdırmasını sağlayabilirsiniz.

Son olarak, Git, şu anda kullandığınız repoya ait olan Git dizinindeki yapılandırma değerlerini arar (`.git/config`).
Bu değerler yalnızca o repoya özgüdür ve `git config` komutuna `--local` seçeneğini eklemeyi temsil eder.
(Hangi düzeyde çalışmak istediğinizi belirtmezseniz, varsayılan olarak bu ayar kullanılır.)

Bu "düzeylerin" (sistem, global, yerel) her biri, önceki düzeydeki değerleri geçersiz kılar; bu nedenle `.git/config` dosyasındaki değerler, örneğin, `/etc/gitconfig` dosyasındakilerin önüne geçer.

[NOTE]
====
Git'in yapılandırma dosyaları düz metindir. Bu nedenle bu değerleri doğru sözdizimini eklemek şartıyla, manuel olarak da belirleyebilirsiniz.
Ancak genellikle `git config` komutunu çalıştırmak daha kolaydır.
====

==== Temel İstemci Yapılandırması

Git tarafından tanınan yapılandırma seçenekleri iki kategoriye ayrılır: istemci tarafı ve sunucu tarafı.
Seçeneklerin çoğu istemci tarafındadır (kişisel çalışma tercihlerinizi yapılandırır).
Çok fazla yapılandırma seçeneği desteklenir, ancak bunların büyük bir kısmı yalnızca belirli uç durumlarda kullanışlıdır (burada sadece en yaygın ve kullanışlı seçenekleri ele alacağız).
Git'in kullandığınız sürümünün tanıdığı tüm seçeneklerin bir listesini görmek istiyorsanız, şunu çalıştırabilirsiniz:

[source,console]
----
$ man git-config
----

Bu komut, detaylı bir şekilde mevcut tüm seçenekleri listeler.
Bu başvuru materyalini ayrıca şu adreste bulabilirsiniz: https://git-scm.com/docs/git-config[].

===== `core.editor`

((($EDITOR)))((($VISUAL, see $EDITOR)))
Git varsayılan olarak, bir kabuk (shell) ortam değişkeni olan `VISUAL` veya `EDITOR` 'da sizin belirttiğiniz varsayılan metin düzenleyicisini kullanır, aksi durumdaysa katkı ve etiket mesajlarını oluşturmak ve düzenlemek için `vi` düzenleyicisine geri döner.
Bu varsayılanı başka bir şeye değiştirmek için, `core.editor` ayarını kullanabilirsiniz:

[source,console]
----
$ git config --global core.editor emacs
----

Artık, varsayılan kabuk düzenleyiciniz ne olursa olsun, Git mesajları düzenlemek için Emacs'i başlatacaktır.

===== `commit.template`

(((commit templates)))
Bu değeri sisteminizde bir dosyanın yoluna ayarlarsanız, Git bu dosyayı bir katkı oluştururken varsayılan başlangıç mesajı olarak kullanacaktır.
Özel bir katkı şablonu oluşturmanın önemi: bir katkı mesajı oluştururken, (kendinize veya başkalarına) doğru biçim ve stili hatırlatmak için kullanılabilmesidir.

Örneğin, `~/.gitmessage.txt` adresinde şöyle bir şablon dosyası düşünün:

[source,text]
----
Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
----

Bu katkı şablonunun, katkı işleyen kişiyi; ( `git log --oneline` çıktısı için) başlık satırını kısa tutmaya, altına daha fazla ayrıntı eklemeye ve varsa bir soruna veya iş paketi takip numarasına atıfta bulunmaya yönelttiğini görebilirsiniz.

`git commit` komutunu çalıştırdığınızda düzenleyicinizde görünen varsayılan mesajı bu şablon olarak kullanılması için, `commit.template` yapılandırma değerini ayarlayın:

[source,console]
----
$ git config --global commit.template ~/.gitmessage.txt
$ git commit
----

Daha sonra, bir katkı işlerken, düzenleyiciniz şöyle bir şey gösterecek:

[source,text]
----
Subject line (try to keep under 50 characters)

Multi-line description of commit,
feel free to be detailed.

[Ticket: X]
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#   (use "git reset HEAD <file>..." to unstage)
#
# modified:   lib/test.rb
#
~
~
".git/COMMIT_EDITMSG" 14L, 297C
----

Eğer ekibinizin bir katkı mesajı politikası varsa, o politikanın bir şablonunu sisteminize yerleştirmek ve Git'i varsayılan olarak kullanması için yapılandırmak, bu politikanın düzenli olarak uygulanma şansını arttıracaktır.

===== `core.pager`

(((pager)))
Bu ayar, Git'in `log` ve `diff` gibi çıktıları yazdırdığında hangi sayfa düzeninin kullanılacağını belirler.
Bunu varsayılan olarak `less` şeklinde bırakabilir, `more` olarak ayarlanabilir veya boş bir dize olarak ayarlayarak devre dışı bırakabilirsiniz.

[source,console]
----
$ git config --global core.pager ''
----

Bunu çalıştırırsanız, ne kadar uzun olursa olsun, Git tüm komutların çıktısını ekrana yazdırır.

===== `user.signingkey`

(((GPG)))
Eğer (<<ch07-git-tools#_signing>> bölümünde anlatıldığı gibi) imzalı açıklama etiketleri oluşturuyorsanız, GPG imzalama anahtarınızı bir yapılandırma ayarı olarak belirlemeniz işlerinizi kolaylaştırır.
Anahtar kimliğinizi şu şekilde ayarlayın:

[source,console]
----
$ git config --global user.signingkey <gpg-key-id>
----

Artık `git tag` komutu ile anahtarınızı belirtmeden etiketleri her seferinde imzalayabilirsiniz.

[source,console]
----
$ git tag -s <tag-name>
----

===== `core.excludesfile`

(((excludes)))(((.gitignore)))
(<<ch02-git-basics#_ignoring>> bölümünde anlatıldığı gibi) projenizin `.gitignore` dosyasına belli dosya yolu desenleri koyarak, Git'in o dosyaları takip edilmeyen dosyalar olarak görmemesini veya `git add` komutunu çalıştırdığınızda onları izleme almaya çalışmamasını sağlayabilirsiniz.

Ancak bazen, çalıştığınız tüm repolarda belirli dosyaları yok saymak istersiniz.
Bilgisayarınızda macOS çalışıyorsa, muhtemelen `.DS_Store` dosyalarını biliyorsunuzdur.
Tercih ettiğiniz metin düzenleyici Emacs veya Vim ise, `~` ile biten veya `.swp` ile biten dosya adlarını biliyorsunuzdur.

Bu ayar, bir tür global `.gitignore` dosyası yazmanızı sağlar.
Bu içeriklere sahip bir `~/.gitignore_global` dosyası oluşturur:

[source,ini]
----
*~
.*.swp
.DS_Store
----

... ve `git config --global core.excludesfile ~/.gitignore_global` komutunu çalıştırırsanız, Git artık bu dosyalarla ilgili sizi bir daha rahatsız etmeyecek.

===== `help.autocorrect`

(((autocorrect)))
Eğer bir komutu yanlış yazarsanız, size şuna benzer bir şey gösterir:

[source,console]
----
$ git chekcout master
git: 'chekcout' is not a git command. See 'git --help'.

Did you mean this?
    checkout
----

Git yardımcı olmak için ne anlatmaya çalıştığınızı anlamaya çalışır, ama sizin yerinize kendisi yapmaz.
`help.autocorrect` 'i 1 olarak ayarlarsanız, Git bu komutu sizin için düzeltip otomatik olarak çalıştıracaktır:

[source,console]
----
$ git chekcout master
WARNING: You called a Git command named 'chekcout', which does not exist.
Continuing under the assumption that you meant 'checkout'
in 0.1 seconds automatically...
----

"0.1 saniye" kısmına dikkat edin. `help.autocorrect` aslında onda bir saniyeyi temsil eden bir tamsayıdır.
Bu nedenle, onu 50 olarak ayarlarsanız; Git size komutu otomatik düzeltmeden önce fikrinizi değiştirebilmeniz için 5 saniye verecektir.

==== Git'te Renkler

(((color)))
Git, komut çıktısını hızlı ve kolay bir şekilde görsel olarak ayrıştırmaya büyük ölçüde yardımcı olan renkli terminal çıktısını tam destekler.
Birkaç seçenek, renklendirmeyi tercihinize göre ayarlamanıza yardımcı olabilir.

===== `color.ui`

Git, çoğu çıktıyı otomatik olarak renklendirir, ancak bu davranışı beğenmezseniz bir ana anahtar da vardır.
Git'in tüm renkli terminal çıktısını kapatmak için şunu yapın:

[source,console]
----
$ git config --global color.ui false
----

Varsayılan ayar `auto` 'dur. 
Bu, çıktı doğrudan bir terminale giderken renklendirme yapar, ancak çıktı bir boru (pipe) veya bir dosyaya yönlendirildiğinde renk kontrol kodlarını atlar.

Ayrıca, terminal ve borular arasındaki farkı yok saymak için onu `always` olarak da ayarlayabilirsiniz.
Bunu nadiren isteyeceksiniz; çoğu zaman, yönlendirilmiş çıktınızda renk kodları istiyorsanız, Git buna zorlamak için komuta bir `--color` bayrağı geçirerek bunu sağlayabilirsiniz.
Varsayılan ayar zaten neredeyse her zaman isteyeceğiniz şekildedir.

===== `color.*`

Belirli komutların nasıl renklendirileceği hakkında daha özelleştirici olmak isterseniz, Git, fiile özgü renklendirme ayarları da sunar.
Her birini `true`, `false` veya `always` olarak ayarlayabilirsiniz:

  color.branch
  color.diff
  color.interactive
  color.status

Ayrıca, her birinin (her rengi geçersiz kılacak şekilde) çıktının belirli bölümleri için belirli renkler ayarlamak için kullanabileceğiniz alt ayarları vardır.
Örneğin, diff çıktınızdaki meta bilgilerini mavi ön plan, siyah arka plan ve kalın metin olarak ayarlamak için şunu çalıştırabilirsiniz:

[source,console]
----
$ git config --global color.diff.meta "blue black bold"
----

Renk seçeneğini aşağıdaki değerlerden biri olarak ayarlayabilirsiniz: `normal`, `black`, `red`, `green`, `yellow`, `blue`, `magenta`, `cyan`, veya `white`.
Önceki örnekteki gibi kalın gibi bir öznitelik istiyorsanız, `bold`, `dim`, `ul` (altını çizmek), `blink`, ve `reverse` (ön planı ve arka planı değiştirmek) seçeneklerinden birini seçebilirsiniz.

[[_external_merge_tools]]
==== External Merge and Diff Tools

(((mergetool)))(((difftool)))
Although Git has an internal implementation of diff, which is what we've been showing in this book, you can set up an external tool instead.
You can also set up a graphical merge-conflict-resolution tool instead of having to resolve conflicts manually.
We'll demonstrate setting up the Perforce Visual Merge Tool (P4Merge) to do your diffs and merge resolutions, because it's a nice graphical tool and it's free.

If you want to try this out, P4Merge works on all major platforms, so you should be able to do so.
We'll use path names in the examples that work on macOS and Linux systems; for Windows, you'll have to change `/usr/local/bin` to an executable path in your environment.

To begin, https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools[download P4Merge from Perforce].
Next, you'll set up external wrapper scripts to run your commands.
We'll use the macOS path for the executable; in other systems, it will be where your `p4merge` binary is installed.
Set up a merge wrapper script named `extMerge` that calls your binary with all the arguments provided:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/p4merge.app/Contents/MacOS/p4merge $*
----

The diff wrapper checks to make sure seven arguments are provided and passes two of them to your merge script.
By default, Git passes the following arguments to the diff program:

[source]
----
path old-file old-hex old-mode new-file new-hex new-mode
----

Because you only want the `old-file` and `new-file` arguments, you use the wrapper script to pass the ones you need.

[source,console]
----
$ cat /usr/local/bin/extDiff
#!/bin/sh
[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
----

You also need to make sure these tools are executable:

[source,console]
----
$ sudo chmod +x /usr/local/bin/extMerge
$ sudo chmod +x /usr/local/bin/extDiff
----

Now you can set up your config file to use your custom merge resolution and diff tools.
This takes a number of custom settings: `merge.tool` to tell Git what strategy to use, `mergetool.<tool>.cmd` to specify how to run the command, `mergetool.<tool>.trustExitCode` to tell Git if the exit code of that program indicates a successful merge resolution or not, and `diff.external` to tell Git what command to run for diffs.
So, you can either run four config commands

[source,console]
----
$ git config --global merge.tool extMerge
$ git config --global mergetool.extMerge.cmd \
  'extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"'
$ git config --global mergetool.extMerge.trustExitCode false
$ git config --global diff.external extDiff
----
or you can edit your `~/.gitconfig` file to add these lines:

[source,ini]
----
[merge]
  tool = extMerge
[mergetool "extMerge"]
  cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED"
  trustExitCode = false
[diff]
  external = extDiff
----

After all this is set, if you run diff commands such as this:

[source,console]
----
$ git diff 32d1776b1^ 32d1776b1
----

Instead of getting the diff output on the command line, Git fires up P4Merge, which looks something like this:

.P4Merge.
image::images/p4merge.png[P4Merge.]

If you try to merge two branches and subsequently have merge conflicts, you can run the command `git mergetool`; it starts P4Merge to let you resolve the conflicts through that GUI tool.

The nice thing about this wrapper setup is that you can change your diff and merge tools easily.
For example, to change your `extDiff` and `extMerge` tools to run the KDiff3 tool instead, all you have to do is edit your `extMerge` file:

[source,console]
----
$ cat /usr/local/bin/extMerge
#!/bin/sh
/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*
----

Now, Git will use the KDiff3 tool for diff viewing and merge conflict resolution.

Git comes preset to use a number of other merge-resolution tools without your having to set up the cmd configuration.
To see a list of the tools it supports, try this:

[source,console]
----
$ git mergetool --tool-help
'git mergetool --tool=<tool>' may be set to one of the following:
        emerge
        gvimdiff
        gvimdiff2
        opendiff
        p4merge
        vimdiff
        vimdiff2

The following tools are valid, but not currently available:
        araxis
        bc3
        codecompare
        deltawalker
        diffmerge
        diffuse
        ecmerge
        kdiff3
        meld
        tkdiff
        tortoisemerge
        xxdiff

Some of the tools listed above only work in a windowed
environment. If run in a terminal-only session, they will fail.
----

If you're not interested in using KDiff3 for diff but rather want to use it just for merge resolution, and the kdiff3 command is in your path, then you can run

[source,console]
----
$ git config --global merge.tool kdiff3
----

If you run this instead of setting up the `extMerge` and `extDiff` files, Git will use KDiff3 for merge resolution and the normal Git diff tool for diffs.

==== Formatting and Whitespace

(((whitespace)))
Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform.
It's very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them, and if your files ever touch a Windows system, their line endings might be replaced.
Git has a few configuration options to help with these issues.

===== `core.autocrlf`

(((crlf)))(((line endings)))
If you're programming on Windows and working with people who are not (or vice-versa), you'll probably run into line-ending issues at some point.
This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas macOS and Linux systems use only the linefeed character.
This is a subtle but incredibly annoying fact of cross-platform work; many editors on Windows silently replace existing LF-style line endings with CRLF, or insert both line-ending characters when the user hits the enter key.

Git can handle this by auto-converting CRLF line endings into LF when you add a file to the index, and vice versa when it checks out code onto your filesystem.
You can turn on this functionality with the `core.autocrlf` setting.
If you're on a Windows machine, set it to `true` -- this converts LF endings into CRLF when you check out code:

[source,console]
----
$ git config --global core.autocrlf true
----

If you're on a Linux or macOS system that uses LF line endings, then you don't want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it.
You can tell Git to convert CRLF to LF on commit but not the other way around by setting `core.autocrlf` to input:

[source,console]
----
$ git config --global core.autocrlf input
----

This setup should leave you with CRLF endings in Windows checkouts, but LF endings on macOS and Linux systems and in the repository.

If you're a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to `false`:

[source,console]
----
$ git config --global core.autocrlf false
----

===== `core.whitespace`

Git comes preset to detect and fix some whitespace issues.
It can look for six primary whitespace issues -- three are enabled by default and can be turned off, and three are disabled by default but can be activated.

The three that are turned on by default are `blank-at-eol`, which looks for spaces at the end of a line; `blank-at-eof`, which notices blank lines at the end of a file; and `space-before-tab`, which looks for spaces before tabs at the beginning of a line.

The three that are disabled by default but can be turned on are `indent-with-non-tab`, which looks for lines that begin with spaces instead of tabs (and is controlled by the `tabwidth` option); `tab-in-indent`, which watches for tabs in the indentation portion of a line; and `cr-at-eol`, which tells Git that carriage returns at the end of lines are OK.

You can tell Git which of these you want enabled by setting `core.whitespace` to the values you want on or off, separated by commas.
You can disable an option by prepending a `-` in front of its name, or use the default value by leaving it out of the setting string entirely.
For example, if you want all but `space-before-tab` to be set, you can do this (with `trailing-space` being a short-hand to cover both `blank-at-eol` and `blank-at-eof`):

[source,console]
----
$ git config --global core.whitespace \
    trailing-space,-space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

Or you can specify the customizing part only:

[source,console]
----
$ git config --global core.whitespace \
    -space-before-tab,indent-with-non-tab,tab-in-indent,cr-at-eol
----

Git will detect these issues when you run a `git diff` command and try to color them so you can possibly fix them before you commit.
It will also use these values to help you when you apply patches with `git apply`.
When you're applying patches, you can ask Git to warn you if it's applying patches with the specified whitespace issues:

[source,console]
----
$ git apply --whitespace=warn <patch>
----

Or you can have Git try to automatically fix the issue before applying the patch:

[source,console]
----
$ git apply --whitespace=fix <patch>
----

These options apply to the `git rebase` command as well.
If you've committed whitespace issues but haven't yet pushed upstream, you can run `git rebase --whitespace=fix` to have Git automatically fix whitespace issues as it's rewriting the patches.

==== Server Configuration

Not nearly as many configuration options are available for the server side of Git, but there are a few interesting ones you may want to take note of.

===== `receive.fsckObjects`

Git is capable of making sure every object received during a push still matches its SHA-1 checksum and points to valid objects.
However, it doesn't do this by default; it's a fairly expensive operation, and might slow down the operation, especially on large repositories or pushes.
If you want Git to check object consistency on every push, you can force it to do so by setting `receive.fsckObjects` to true:

[source,console]
----
$ git config --system receive.fsckObjects true
----

Now, Git will check the integrity of your repository before each push is accepted to make sure faulty (or malicious) clients aren't introducing corrupt data.

===== `receive.denyNonFastForwards`

If you rebase commits that you've already pushed and then try to push again, or otherwise try to push a commit to a remote branch that doesn't contain the commit that the remote branch currently points to, you'll be denied.
This is generally good policy; but in the case of the rebase, you may determine that you know what you're doing and can force-update the remote branch with a `-f` flag to your push command.

To tell Git to refuse force-pushes, set `receive.denyNonFastForwards`:

[source,console]
----
$ git config --system receive.denyNonFastForwards true
----

The other way you can do this is via server-side receive hooks, which we'll cover in a bit.
That approach lets you do more complex things like deny non-fast-forwards to a certain subset of users.

===== `receive.denyDeletes`

One of the workarounds to the `denyNonFastForwards` policy is for the user to delete the branch and then push it back up with the new reference.
To avoid this, set `receive.denyDeletes` to true:

[source,console]
----
$ git config --system receive.denyDeletes true
----

This denies any deletion of branches or tags -- no user can do it.
To remove remote branches, you must remove the ref files from the server manually.
There are also more interesting ways to do this on a per-user basis via ACLs, as you'll learn in <<ch08-customizing-git#_an_example_git_enforced_policy>>.
