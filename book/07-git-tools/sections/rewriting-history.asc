[[_rewriting_history]]
=== Geçmişi Yeniden Yazma

Git ile çalışırken, yerel katkı geçmişinizi gözden geçirmek isteyebilirsiniz.
Git'in harika özelliklerinden biri, son anda kararlar almanıza olanak tanımasıdır.
İzlemde katkı öncesi hangi dosyaların hangi katkılara gideceğine karar verebilir, `git stash` ile bir şey üzerinde henüz üzerinde çalışmak istemediğinize karar verebilir ve zaten işlenmiş olan katkıları başka bir şekilde gerçekleşmiş gibi yeniden yazabilirsiniz.
Bu, katkıların sırasını, mesajlarını veya bir katkıdaki dosyaları değiştirmeyi, katkıları birleştirmeyi veya ayırmayı veya işlenmiş katkıları tamamen kaldırmayı içerebilir - tüm bunları çalışmalarınızı başkalarıyla paylaşmadan önce yapabilirsiniz.

Bu bölümde, bu görevleri nasıl gerçekleştireceğinizi göreceksiniz, böylece çalışmanızı diğerleriyle paylaşmadan önce katkı geçmişinizin istediğiniz gibi görünmesini sağlayabilirsiniz.

[NOT]
.Çalışmanız sizi tatmin edecek seviyeye gelene kadar itmeyin
====
Git'in temel kurallarından biri, kopyanız içindeki çoğu şeyin yerel olması nedeniyle, geçmişinizi _yerel olarak_ yeniden yazma özgürlüğünüzün olduğudur.
Ancak, çalışmanızı gönderdikten sonra işler tamamen farklı olur ve onu değiştirmek için iyi bir nedeniniz yoksa, gönderilen işi öyle kabul etmelisiniz.
Kısacası, çalışmanız sizi memnun edinceye kadar itmeyin ve hazır olana kadar dış dünya ile paylaşmayın.
====

[[_git_amend]]
==== Son Katkıyı Değiştirme

En son katkınızı değiştirmek, muhtemelen yapacağınız en yaygın tarih yazma işlemidir.
Genellikle en son katkınız üzerinde iki temel şey yapmak istersiniz: sadece katkı mesajını değiştirmek ya da dosya ekleyip, kaldırarak veya değiştirerek katkının gerçek içeriğini değiştirmek.

Eğer sadece son katkı mesajınızı değiştirmek istiyorsanız, bu kolaydır:

[source,console]
----
$ git commit --amend
----

Yukarıdaki komut, önceki katkı mesajını bir düzenleyici oturumuna yükler; burada mesajı değiştirebilir, bu değişiklikleri kaydedebilir ve çıkabilirsiniz.
Düzenleyiciyi kaydedip kapatırsanız, düzenleyici güncellenmiş katkı mesajını içeren yeni bir katkı yazar ve onu yeni son katkınız yapar.

Eğer son katkınızın _içeriğini_ değiştirmek istiyorsanız, işlem temel olarak aynı şekilde çalışır: önce unuttuğunuz değişiklikleri yapın ve bu değişiklikleri izleme alın. Ardından çalıştıracağınız `git commit --amend` komutu; son katkınızı, yeni ve geliştirilmiş bir katkı ile _değiştirir_.

Bu teknikle dikkatli olmanız gerekmektedir çünkü `amend` komutu, katkının SHA-1 karmasını değiştirir.
Bu, çok küçük boyutta bir yeniden temellemeye benzer - eğer çoktan uzak repoya ittiyseniz son katkınızı değiştirmeyin.

[İPUCU]
.Düzeltme yapılan bir katkı, bir düzeltilmiş katkı mesajına ihtiyaç duyabilir (veya duymayabilir).
====
İşlenmiş bir katkıyı düzelttiğinizde, hem katkı mesajını hem de katkının içeriğini değiştirme fırsatınız vardır. 
Eğer katkının içeriğini önemli ölçüde değiştiriyorsanız, düzeltilmiş içeriği yansıtacak şekilde katkı mesajını da güncellemelisiniz.

Öte yandan, düzeltmeleriniz yeterince küçükse (aptal bir yazım hatasını düzeltmek veya izleme almayı unuttuğunuz bir dosyayı eklemek gibi) ve önceki katkı mesajı tamamen uygunsuz değilse; basitçe değişiklikleri yapın, bunları izleme alın ve gereksiz yere düzenleyici oturumunu açmaktan kaçının:

[source,console]
----
$ git commit --amend --no-edit
----

====

[[_changing_multiple]]
==== Çoklu Katkı Mesajı Değişimi

Geçmişte daha geride olan bir katkıyı değiştirmek için daha karmaşık araçlara geçiş yapmanız gerekir. 
Git'in bir tarih değiştirme aracı yoktur, ancak `rebase` komutunu kullanarak bir dizi katkıyı başka bir yere taşımak yerine başlangıçta dayandıkları HEAD'e yeniden temelleyebilirsiniz. 
Etkileşimli temelleme aracı ile, değiştirmek istediğiniz her katkıdan sonra durabilir; mesajı değiştirebilir, dosyaları ekleyebilir veya istediğiniz her şeyi yapabilirsiniz.
Etkileşimli temellemeyi `git rebase` komutuna `-i` seçeneğini ekleyerek çalıştırabilirsiniz. 
Hangi katkıyı yeniden temellemek istediğinizi belirtmek için, katkıların hangi katkıya yeniden temelleneceğini söyleyerek ne kadar geriye gitmek istediğinizi belirtmelisiniz.

Örneğin, son üç katkı mesajını veya bu gruptaki herhangi bir katkı mesajını değiştirmek istiyorsanız, `git rebase -i` komutuna düzenlemek istediğiniz son katkının öncelini (yani `HEAD~2^` veya `HEAD~3`) argüman olarak sağlarsınız. 
`~3` 'ü hatırlamak daha kolay olabilir, çünkü son üç katkıyı düzenlemeye çalışıyorsunuz, ancak aslında düzenlemek istediğiniz son katkının dört katkı öncesini belirlediğinizi unutmayın:

[source,console]
----
$ git rebase -i HEAD~3
----

Remember again that this is a rebasing command -- every commit in the range `HEAD~3..HEAD` with a changed message _and all of its descendants_ will be rewritten.
Don't include any commit you've already pushed to a central server -- doing so will confuse other developers by providing an alternate version of the same change.

Running this command gives you a list of commits in your text editor that looks something like this:

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

It's important to note that these commits are listed in the opposite order than you normally see them using the `log` command.
If you run a `log`, you see something like this:

[source,console]
----
$ git log --pretty=format:"%h %s" HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
----

Notice the reverse order.
The interactive rebase gives you a script that it's going to run.
It will start at the commit you specify on the command line (`HEAD~3`) and replay the changes introduced in each of these commits from top to bottom.
It lists the oldest at the top, rather than the newest, because that's the first one it will replay.

You need to edit the script so that it stops at the commit you want to edit.
To do so, change the word `pick' to the word `edit' for each of the commits you want the script to stop after.
For example, to modify only the third commit message, you change the file to look like this:

[source,console]
----
edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:

[source,console]
----
$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you're satisfied with your changes, run

       git rebase --continue
----

These instructions tell you exactly what to do.
Type

[source,console]
----
$ git commit --amend
----

Change the commit message, and exit the editor.
Then, run

[source,console]
----
$ git rebase --continue
----

This command will apply the other two commits automatically, and then you're done.
If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit.
Each time, Git will stop, let you amend the commit, and continue when you're finished.

==== Reordering Commits

You can also use interactive rebases to reorder or remove commits entirely.
If you want to remove the ``added cat-file'' commit and change the order in which the other two commits are introduced, you can change the rebase script from this

[source,console]
----
pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

to this:

[source,console]
----
pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
----

When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies `310154e` and then `f7f3f6d`, and then stops.
You effectively change the order of those commits and remove the ``added cat-file'' commit completely.

[[_squashing]]
==== Squashing Commits

It's also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool.
The script puts helpful instructions in the rebase message:

[source,console]
----
#
# Commands:
# p, pick <commit> = use commit
# r, reword <commit> = use commit, but edit the commit message
# e, edit <commit> = use commit, but stop for amending
# s, squash <commit> = use commit, but meld into previous commit
# f, fixup <commit> = like "squash", but discard this commit's log message
# x, exec <command> = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with 'git rebase --continue')
# d, drop <commit> = remove commit
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c <commit> to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
----

If, instead of ``pick'' or ``edit'', you specify ``squash'', Git applies both that change and the change directly before it and makes you merge the commit messages together.
So, if you want to make a single commit from these three commits, you make the script look like this:

[source,console]
----
pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
----

When you save and exit the editor, Git applies all three changes and then puts you back into the editor to merge the three commit messages:

[source,console]
----
# This is a combination of 3 commits.
# The first commit's message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
----

When you save that, you have a single commit that introduces the changes of all three previous commits.

==== Splitting a Commit

Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.
For example, suppose you want to split the middle commit of your three commits.
Instead of ``updated README formatting and added blame'', you want to split it into two commits: ``updated README formatting'' for the first, and ``added blame'' for the second.
You can do that in the `rebase -i` script by changing the instruction on the commit you want to split to ``edit'':

[source,console]
----
pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
----

Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.
When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (`f7f3f6d`), applies the second (`310154e`), and drops you to the console.
There, you can do a mixed reset of that commit with `git reset HEAD^`, which effectively undoes that commit and leaves the modified files unstaged.
Now you can stage and commit files until you have several commits, and run `git rebase --continue` when you're done:

[source,console]
----
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue
----

Git applies the last commit (`a5f4a0d`) in the script, and your history looks like this:

[source,console]
----
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
----

Once again, this changes the SHA-1s of all the commits in your list, so make sure no commit shows up in that list that you've already pushed to a shared repository.

==== The Nuclear Option: filter-branch

There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way -- for instance, changing your email address globally or removing a file from every commit.
The command is `filter-branch`, and it can rewrite huge swaths of your history, so you probably shouldn't use it unless your project isn't yet public and other people haven't based work off the commits you're about to rewrite.
However, it can be very useful.
You'll learn a few of the common uses so you can get an idea of some of the things it's capable of.

[[_removing_file_every_commit]]
===== Removing a File from Every Commit

This occurs fairly commonly.
Someone accidentally commits a huge binary file with a thoughtless `git add .`, and you want to remove it everywhere.
Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.
`filter-branch` is the tool you probably want to use to scrub your entire history.
To remove a file named `passwords.txt` from your entire history, you can use the `--tree-filter` option to `filter-branch`:

[source,console]
----
$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref 'refs/heads/master' was rewritten
----

The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the results.
In this case, you remove a file called `passwords.txt` from every snapshot, whether it exists or not.
If you want to remove all accidentally committed editor backup files, you can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.

You'll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.
It's generally a good idea to do this in a testing branch and then hard-reset your master branch after you've determined the outcome is what you really want.
To run `filter-branch` on all your branches, you can pass `--all` to the command.

===== Making a Subdirectory the New Root

Suppose you've done an import from another source control system and have subdirectories that make no sense (`trunk`, `tags`, and so on).
If you want to make the `trunk` subdirectory be the new project root for every commit, `filter-branch` can help you do that, too:

[source,console]
----
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
----

Now your new project root is what was in the `trunk` subdirectory each time.
Git will also automatically remove commits that did not affect the subdirectory.

===== Changing Email Addresses Globally

Another common case is that you forgot to run `git config` to set your name and email address before you started working, or perhaps you want to open-source a project at work and change all your work email addresses to your personal address.
In any case, you can change email addresses in multiple commits in a batch with `filter-branch` as well.
You need to be careful to change only the email addresses that are yours, so you use `--commit-filter`:

[source,console]
----
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
----

This goes through and rewrites every commit to have your new address.
Because commits contain the SHA-1 values of their parents, this command changes every commit SHA-1 in your history, not just those that have the matching email address.
