[[_git_reset]]
=== Reset Komutunun Gizemleri

Daha özelleşmiş araçlara geçmeden önce, Git'in `reset` ve `checkout` komutlarından bahsedelim.
Bu komutlar, ilk kez karşılaştığınızda Git'in en karmaşık kısımlarından ikisidir.
Bu kadar çok şey yaparlar ki, onları gerçekten anlamak ve doğru bir şekilde kullanmak umutsuz görünür.
Bu nedenle, basit bir metafor öneriyoruz.

==== Üç Çalışma Ağacı

Git'in üç farklı çalışma ağacının içeriğini yöneten bir içerik yöneticisi olduğunu hayal etmek, `reset` ve `checkout` komutlarını anlamayı kolaylaştırır.
Burada "ağaç" derken gerçekten "dosya dizinini" kastediyoruz, bir veri yapısı olan ağacı (tree) değil.
(Birkaç durumda, dizin tam olarak bir ağaç gibi davranmaz, ancak şu anda amacımız için bu şekilde düşünmek daha kolaydır.)

Git sistemi normal işleyişinde üç ağacı yönetir ve onları değiştirir:

[cols="1,2",options="header"]
|================================
| Ağaç (Tree)       | Rol
| Uç (HEAD)         | Son katkı pozu, ardıl
| Dizin (Index)     | Önerilen katkı pozu (bir sonraki işlem için)
| Çalışma Dizini    | Kum havuzu (Sandbox)
|================================

===== Uç (HEAD)

Uç, mevcut dalda işlenen son katkının referansını gösteren bir işaretçidir. 
Bunun anlamı, bu "uç"un işlenen bir sonraki katkının önceli olacağıdır. 
Genellikle "uç"u *projenizin o daldaki son katkınızı işlediğiniz andaki anlık görüntüsü (poz)* olarak düşünmek en basit olanıdır.

Aslında, bu pozun nasıl olduğunu görmek oldukça kolaydır. 
İşte, uç pozundaki her dosyanın gerçek dizin listesi ve SHA-1 kontrol toplamlarını almanın bir örneği:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Git'in düşük seviyeli işlerde kullanılan `cat-file` ve `ls-tree` komutları, günlük işlerde pek kullanılmayan; ancak burada neler olup bittiğini görmemize yardımcı olan, ``plumbing'' (boru) komutlarıdır.

[[_the_index]]
===== İndeks (Dizin)

İndeks, *beklenilen sıradaki katkı* işlemidir.
Bu kavramı aynı zamanda Git'in ``İzlem Alanı`` (Staging Area) olarak da adlandırıyoruz, çünkü `git commit` komutunu çalıştırdığınızda Git'in baktığı yer burasıdır.

Git, bu indeksi, çalışma dizininize en son eklenen tüm dosya içeriği listesiyle doldurur ve eklendikleri anda onların aslında neye benzediğine bakar.
Daha sonra, siz bu dosyalardan bazılarını yeniden şekillendirirsiniz ve `git commit` komutu bunu yeni bir katkı için ağaca dönüştürür.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Burada yine, aslında bize dosya dizinimizin şu anda neye benzediğini gösterecek bir perde-gerisi aracı olan, `git ls-files` komutunu kullanıyoruz.

İndeks teknik olarak bir ağaç yapısı değildir - aslında düzleştirilmiş bir dışavurum olarak uygulanmıştır - ancak amacımız için buna yeterince yakındır.

===== Çalışma Dizini

Son olarak, _çalışma dizininiz_ (ayrıca "çalışma ağacı" olarak da adlandırılır).
Diğer iki ağaç, içeriklerini etkili ancak kullanışsız bir şekilde `.git` klasörü içinde saklar.
Çalışma dizini, bunları gerçek dosyalara açar, bu da onları düzenlemenizi çok daha kolay hale getirir.
Çalışma dizinini, değişikliklerinizi (izleme alanına alıp ardından katkı olarak proje geçmişinize eklemeden önce) deneyebileceğiniz bir *kum havuzu* (sandbox) olarak düşünün.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== İş Akışı

Git'in tipik iş akışı, bu üç ağacı manipüle ederek projenizin ardışık olarak daha gelişmiş durumlarının pozlarını kaydetmektir.

image::images/reset-workflow.png[]

Hadi bu süreci görselleştirelim: Diyelim ki tek bir dosyanın bulunduğu yeni bir dizine giriyorsunuz.
Mavi renkte göstereceğimiz bu dosyayı *v1* olarak adlandıralım.
Şimdi `git init` komutunu çalıştırıyoruz: bu daha doğmamış `master` dalına işaret eden bir HEAD referansı ile bir Git reposu oluşturacak.

image::images/reset-ex1.png[]

Bu noktada, sadece çalışma dizini ağacında içerik bulunmaktadır.

Şimdi bu dosyayı katkı olarak işlemek istiyoruz, bu yüzden `git add` komutunu kullanarak çalışma dizinindeki içeriği alıp indekse (izlem) kopyalarız.

image::images/reset-ex2.png[]

Ardından `git commit` komutunu çalıştırırız: bu komut dizinin içeriğini alır ve onu kalıcı bir poz olarak kaydeder, o poza işaret eden bir katkı nesnesi oluşturur ve `master` 'ı bu katkıya işaret edecek şekilde günceller.

image::images/reset-ex3.png[]

`git status` komutunu çalıştırırsak, henüz değişiklik yapmadığımız için, her üç ağacın da aynı olduğunu göreceğiz.

Şimdi dosyayı değiştirip, katkı olarak işlemek istiyoruz.
Aynı süreci geçireceğiz; önce çalışma dizininde dosyayı değiştireceğiz.
Dosyanın bu sürümüne *v2* diyelim ve onu kırmızı renkle gösterelim.

image::images/reset-ex4.png[]

Şu anda `git status` komutunu çalıştırırsak, dosyayı kırmızı renkte ve ``Changes not staged for commit`` açıklamasıyla göreceğiz; çünkü bu giriş indeks ile çalışma dizini arasındaki bir farklılık olarak görünecektir.
Daha sonra bu dosya üzerinde `git add` komutunu çalıştırarak, onu indekse ekliyoruz.

image::images/reset-ex5.png[]

Bu noktada, `git status` komutunu çalıştırırsak, dosyayı yeşil renkte "Yapılacak katkılar" altında göreceğiz; çünkü indeks ile uç farklıdır - yani önerilen sıradaki katkımız, işlenmiş son katkımızdan farklıdır.
Son olarak, katkılama işlemini tamamlamak için `git commit` komutunu çalıştırıyoruz.

image::images/reset-ex6.png[]

Şimdi `git status` komutunu çalıştırdığımızda, tekrar tüm ağaçlar aynı olduğu için herhangi bir çıktı almayacağız.

Dallar arasında geçiş yapmak veya kopyalamak benzer bir süreçten geçer. 
Yeni bir dala geçiş yapmak, *HEAD* işaretçisini yeni dal referansını gösterecek şekilde değiştirir, *indeks* içeriğini o katkının pozuyla doldurur ve son olarak *indeks* içeriğini *çalışma dizinine* kopyalar.

==== Reset Komutunun Rolü

`reset` komutu, bu bağlamda görüldüğünde daha mantıklı hale gelir.

Bu örnekleri daha iyi anlamak için, diyelim ki `file.txt` dosyasını tekrar değiştirdik ve üçüncü kez katkıladık.
Şimdi geçmişimiz şöyle görünüyor:

image::images/reset-start.png[]

Şimdi, `reset` çağrıldığında tam olarak ne yaptığını adım adım görelim.
Basit ve öngörülebilir bir şekilde üç ağacı doğrudan manipüle eder.
Üç temel işlem yapar.

===== Adım 1: HEAD'i Taşı

İlk olarak, `reset` 'in yapacağı şey, HEAD'in işaret ettiği yeri taşımaktır.
Bu, HEAD'in kendisini değiştirmekle aynı değildir (bunu `checkout` yapar); `reset`, HEAD'in işaret ettiği dalı taşır.
Bu, eğer HEAD `master` dalına ayarlanmışsa (yani şu anda `master` dalındaysanız), `git reset 9e5e6a4` komutunu çalıştırdığınızda `master` 'ı `9e5e6a4` noktasına getirecek demektir.

image::images/reset-soft.png[]

Bir katkı ile `reset` 'in hangi biçimini çağırırsanız çağırın, bu her zaman yapmaya çalışacağı ilk şeydir.
`reset --soft` komutuyla orada duracaktır.

Şimdi o diyagrama bir kez daha göz atın ve neler olduğunun farkına varın: temel olarak son `git commit` komutunu geri aldı.
`git commit` komutunu çalıştırdığınızda, Git yeni bir katkı oluşturur ve HEAD'in işaret ettiği dalı oraya taşır.
`reset` komutunu `HEAD~` 'e (HEAD'in önceli) geri alırsanız, dalı indeks veya çalışma dizininde herhangi bir değişiklik yapmadan eski konumuna geri taşırsınız.
Şimdi indeksi güncelleyebilir ve `git commit` komutunu tekrar çalıştırarak `git commit --amend` komutunun yaptığını başarabilirsiniz (bkz <<_git_amend>>).

===== Adım 2: İndeksi Güncelleme (--mixed)

Şimdi `git status` komutunu çalıştırırsanız, indeks ile yeni HEAD arasındaki farkı yeşil renkte göreceksiniz.

`reset` 'in yapacağı bir sonraki şey, indeksi, HEAD'in şu anda işaret ettiği pozun içeriğiyle güncellemektir.

image::images/reset-mixed.png[]

`--mixed` seçeneğini belirtirseniz, `reset` işlemi bu noktada duracaktır.
Bu aynı zamanda varsayılan davranıştır, yani hiçbir seçenek belirtmezseniz (bu durumda yalnızca `git reset HEAD~`), komut burada duracaktır.

Şimdi o diyagrama bir kez daha bir göz atın ve neler olduğunun farkına varın: hala son `commit` işleminizi geri aldınız, ancak aynı zamanda her şey _izlem alanı dışına çıktı_.
Yani, tüm `git add` ve `git commit` komutlarınızı çalıştırmadan önceki duruma geri döndünüz.

===== Adım 3: Çalışma Dizinini Güncelleme (--hard)

`reset` 'in yapacağı üçüncü şey, çalışma dizinini indeks gibi yapmaktır.
`--hard` seçeneğini kullanırsanız, bu aşamaya devam eder.

image::images/reset-hard.png[]

Az önce ne olduğunu bir düşünelim.
Son katkınızı, `git add` ve `git commit` komutlarını, *ve* çalışma dizininde yaptığınız tüm çalışmayı geri aldınız.

`--hard` bayrağının `reset` komutunu tehlikeli hale getiren tek yol olduğunu ve Git'in bir veriyi gerçekten yok edeceği çok az durumdan biri olduğunu bilmeniz çok önemlidir.
`reset` 'in diğer herhangi bir kullanımı oldukça kolay bir şekilde geri alınabilirken, `--hard` seçeneği bunu yapamaz; çünkü çalışma dizinindeki dosyaların üzerine zorla yeniden yazar.
Bu özel durumda, Git veritabanımızda dosyanın *v3* sürümüne bir katkı olarak hala sahibiz ve `reflog` 'umuza bakarak onu geri alabiliriz; ancak onu katkılamadan bıraksaydık, Git o dosyanın üzerine yeniden yazacaktı ve onu geri alınamaz hale getirecekti.

===== Özet

`reset` komutu, belirli bir sırayla bu üç ağacın üzerine yazar ve siz ona durmasını söylediğinizde durur:

1. HEAD'in işaret ettiği dalı taşı _(eğer `--soft` kullanılmışsa burada dur)_
2. İndeksi HEAD'in aynısı yap _(eğer `--hard` kullanılmamışsa burada dur)_
3. Çalışma dizinini indeks gibi yap

==== Reset With a Path

That covers the behavior of `reset` in its basic form, but you can also provide it with a path to act upon.
If you specify a path, `reset` will skip step 1, and limit the remainder of its actions to a specific file or set of files.
This actually sort of makes sense -- HEAD is just a pointer, and you can't point to part of one commit and part of another.
But the index and working directory _can_ be partially updated, so reset proceeds with steps 2 and 3.

So, assume we run `git reset file.txt`.
This form (since you did not specify a commit SHA-1 or branch, and you didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed HEAD file.txt`, which will:

1. Move the branch HEAD points to _(skipped)_
2. Make the index look like HEAD _(stop here)_

So it essentially just copies `file.txt` from HEAD to the index.

image::images/reset-path1.png[]

This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.

image::images/reset-path2.png[]

This is why the output of the `git status` command suggests that you run this to unstage a file.
(See <<ch02-git-basics#_unstaging>> for more on this.)

We could just as easily not let Git assume we meant ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

This effectively does the same thing as if we had reverted the content of the file to *v1* in the working directory, ran `git add` on it, then reverted it back to *v3* again (without actually going through all those steps).
If we run `git commit` now, it will record a change that reverts that file back to *v1*, even though we never actually had it in our working directory again.

It's also interesting to note that like `git add`, the `reset` command will accept a `--patch` option to unstage content on a hunk-by-hunk basis.
So you can selectively unstage or revert content.

==== Squashing

Let's look at how to do something interesting with this newfound power -- squashing commits.

Say you have a series of commits with messages like ``oops.'', ``WIP'' and ``forgot this file''.
You can use `reset` to quickly and easily squash them into a single commit that makes you look really smart.
(<<_squashing>> shows another way to do this, but in this example it's simpler to use `reset`.)

Let's say you have a project where the first commit has one file, the second commit added a new file and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it down.

image::images/reset-squash-r1.png[]

You can run `git reset --soft HEAD~2` to move the HEAD branch back to an older commit (the most recent commit you want to keep):

image::images/reset-squash-r2.png[]

And then simply run `git commit` again:

image::images/reset-squash-r3.png[]

Now you can see that your reachable history, the history you would push, now looks like you had one commit with `file-a.txt` v1, then a second that both modified `file-a.txt` to v3 and added `file-b.txt`.
The commit with the v2 version of the file is no longer in the history.

==== Check It Out

Finally, you may wonder what the difference between `checkout` and `reset` is.
Like `reset`, `checkout` manipulates the three trees, and it is a bit different depending on whether you give the command a file path or not.

===== Without Paths

Running `git checkout [branch]` is pretty similar to running `git reset --hard [branch]` in that it updates all three trees for you to look like `[branch]`, but there are two important differences.

First, unlike `reset --hard`, `checkout` is working-directory safe; it will check to make sure it's not blowing away files that have changes to them.
Actually, it's a bit smarter than that -- it tries to do a trivial merge in the working directory, so all of the files you _haven't_ changed will be updated.
`reset --hard`, on the other hand, will simply replace everything across the board without checking.

The second important difference is how `checkout` updates HEAD.
Whereas `reset` will move the branch that HEAD points to, `checkout` will move HEAD itself to point to another branch.

For instance, say we have `master` and `develop` branches which point at different commits, and we're currently on `develop` (so HEAD points to it).
If we run `git reset master`, `develop` itself will now point to the same commit that `master` does.
If we instead run `git checkout master`, `develop` does not move, HEAD itself does.
HEAD will now point to `master`.

So, in both cases we're moving HEAD to point to commit A, but _how_ we do so is very different.
`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.

image::images/reset-checkout.png[]

===== With Paths

The other way to run `checkout` is with a file path, which, like `reset`, does not move HEAD.
It is just like `git reset [branch] file` in that it updates the index with that file at that commit, but it also overwrites the file in the working directory.
It would be exactly like `git reset --hard [branch] file` (if `reset` would let you run that) -- it's not working-directory safe, and it does not move HEAD.

Also, like `git reset` and `git add`, `checkout` will accept a `--patch` option to allow you to selectively revert file contents on a hunk-by-hunk basis.

==== Summary

Hopefully now you understand and feel more comfortable with the `reset` command, but are probably still a little confused about how exactly it differs from `checkout` and could not possibly remember all the rules of the different invocations.

Here's a cheat-sheet for which commands affect which trees.
The ``HEAD'' column reads ``REF'' if that command moves the reference (branch) that HEAD points to, and ``HEAD'' if it moves HEAD itself.
Pay especial attention to the 'WD Safe?' column -- if it says *NO*, take a second to think before running that command.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout <commit>` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset [commit] <paths>` | NO | YES | NO | YES
| `checkout [commit] <paths>` | NO | YES | YES | *NO*
|================================
