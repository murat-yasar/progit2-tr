[[_advanced_merging]]
=== İleri Seviye Birleştirme

Git'te birleştirme genellikle çok kolaydır.
Git, başka bir dalı bir çok defa birleştirmeyi kolaylaştırdığı için; ufak çakışmaları sık sık çözerek, çok uzun ömürlü dallarınızı bile sürekli güncel tutabilir ve böylece en sonda devasa tek bir çakışmayla karşılaşmazsınız.

Ancak, bazen zorlu çatışmalar ortaya çıkabilir.
Diğer bazı sürüm kontrol sistemlerinin aksine, Git birleştirme çakışması çözümünde "aşırı akıllı" olmaya çalışmaz.
Git'in felsefesi, birleştirme çözümünün net olduğunu belirlemede akıllı olmaktır. Ancak bir çakışma varsa, onu otomatik olarak çözmeye çalışmak konusunda akıllı davranmaz.
Bu nedenle, hızla ayrılan iki dalı birleştirmek için çok uzun süre beklerseniz, bazı sorunlarla karşılaşabilirsiniz.

Bu bölümde, bu sorunların neler olabileceğini ve Git'in size bu daha zorlu durumlarla başa çıkmada yardımcı olmak için hangi araçları sunduğunu ele alacağız.
Ayrıca, yapabileceğiniz farklı, standart olmayan birleştirmelerin bazılarını ele alacak ve yaptığınız birleştirmelerden nasıl geri adım atılacağını göreceğiz.

==== Birleştirme Çakışmaları

Çok karmaşık çatışmalar için bazı temel adımları <<ch03-git-branching#_basic_merge_conflicts>> bölümünde ele almış olsak da, Git daha karmaşık çatışmaları çözmenize ve bunlarla daha iyi başa çıkmanıza yardımcı olmak için birkaç araç sağlar.

Öncelikle, mümkünse, çatışma olabilecek birleştirmeyi yapmadan önce çalışma dizininizin temiz olduğundan emin olmaya çalışın.
Geliştirmeye devam ettiğiniz bir çalışmanız varsa, bunu geçici bir dalda katkılayın veya `stash` ile saklayın.
Bu burada denediğiniz *herhangi bir şeyi* geri almanızı sağlar.
Birleştirmeyi yaparken çalışma dizininizde kaydedilmemiş değişiklikleriniz varsa, verdiğimiz ipuçlarından bazıları bu çalışmayı korumanıza yardımcı olabilir.

Şimdi çok basit bir örnek üzerinden ilerleyelim.
'hello world' yazısını yazdıran çok basit bir Ruby dosyamız var.

[source,ruby]
----
#! /usr/bin/env ruby

def hello
  puts 'hello world'
end

hello()
----

Repomuzda, `whitespace` adında yeni bir dal oluşturuyoruz ve tüm Unix satır sonlarını DOS satır sonlarına çevirerek yolumuza devam ediyoruz. Esasında dosyanın her satırını sadece boşluklarla değiştirmiş olduk.
Ardından da ``hello world`` satırını ``hello mundo`` olarak değiştiriyoruz.

[source,console]
----
$ git checkout -b whitespace
Switched to a new branch 'whitespace'

$ unix2dos hello.rb
unix2dos: converting file hello.rb to DOS format ...
$ git commit -am 'converted hello.rb to DOS'
[whitespace 3270f76] converted hello.rb to DOS
 1 file changed, 7 insertions(+), 7 deletions(-)

$ vim hello.rb
$ git diff -b
diff --git a/hello.rb b/hello.rb
index ac51efd..e85207e 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
 #! /usr/bin/env ruby

 def hello
-  puts 'hello world'
+  puts 'hello mundo'^M
 end

 hello()

$ git commit -am 'hello mundo change'
[whitespace 6d338d2] hello mundo change
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Şimdi `master` dalımıza geçiyoruz ve fonksiyon için bazı dokümentasyon belgeleri ekliyoruz.

[source,console]
----
$ git checkout master
Switched to branch 'master'

$ vim hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index ac51efd..36c06c8 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello world'
 end

$ git commit -am 'document the function'
[master bec6336] document the function
 1 file changed, 1 insertion(+)
----

Şimdi `whitespace` dalını birleştirmeyi deneriz ve boşluk değişiklikleri nedeniyle çatışma alırız.

[source,console]
----
$ git merge whitespace
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

[[_abort_merge]]
===== Birleştirmeyi İptal

Şimdi birkaç seçeneğimiz var.
Öncelikle, bu durumdan nasıl çıkacağımızı ele alalım.
Belki de çatışmaları beklemiyordunuz ve şu anda durumla uğraşmak istemiyorsunuz; bu durumda `git merge --abort` komutu ile birleştirmeyi hemen iptal edebilirsiniz.

[source,console]
----
$ git status -sb
## master
UU hello.rb

$ git merge --abort

$ git status -sb
## master
----

`git merge --abort` seçeneği, birleştirmeyi çalıştırmadan önceki durumunuza geri çevirmeye çalışır.
Bu işlemi mükemmel bir şekilde yapamayabileceğiz tek durum, çalışma dizinizde birleştirmeyi çalıştırdığınızda kaydedilmemiş veya katkılanmamış değişiklikleriniz olmasıdır. Aksi takdirde sorunsuz çalışması beklenir.

Eğer bir sebeple sıfırdan başlamak istiyorsanız, `git reset --hard HEAD` komutunu da çalıştırabilir ve reponun en son katkı işlenmiş durumuna geri dönebilirsiniz.
Unutmayın ki, katkılanmamış çalışmalarınız kaybolur, bu yüzden değişikliklerinizden hiçbirini birini istemediğinizden emin olun.

===== Boşlukları (Whitespace) Yoksayma

Bu özel senaryoda, çakışmalar boşluklarla ilgilidir.
Örnek basit olduğundan bunu biliyoruz, ancak gerçek durumlarda da çakışmayı incelediğinizde bu oldukça kolay anlaşılır. Çünkü her satır bir taraftan kaldırılır ve diğer tarafta yeniden eklenir.
Varsayılan olarak, Git tüm bu satırları değişmiş olarak görür, bu yüzden dosyaları birleştiremez.

Ancak varsayılan birleştirme stratejisi argümanlar alabilir ve bunlardan birkaçı boşluk değişikliklerini doğru şekilde yok saymayla ilgilidir.
Birleştirmede çok sayıda boşluk sorunu olduğunu görürseniz, doğrudan birleştirmeyi iptal edip `-Xignore-all-space` veya `-Xignore-space-change` ile tekrarlayabilirsiniz.
İlk seçenek, satırları karşılaştırırken boşlukları *tamamen* yoksayar; ikincisi ise bir veya daha fazla boşluk karakteri dizilerini eşit kabul eder.

[source,console]
----
$ git merge -Xignore-space-change whitespace
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)
----

Bu örnekte, gerçek dosya değişiklikleri çatışmıyordu. Dolayısıyla boşluk değişikliklerini yoksaydığımızda, her şey sorunsuz bir şekilde birleşir.

Ekip üyelerinizden birinin ara sıra her şeyi (boşluklardan sekme karakterlerine veya tersi yönde) yeniden biçimlendirmek gibi bir karakteri varsa, bu özellik gerçekten hayat kurtarıcıdır.

[[_manual_remerge]]
===== Manuel Olarak Yeniden Birleştirme

Git boşluk ön işlemesini oldukça iyi bir şekilde ele alsa da, Git'in otomatik olarak halledemediği ancak betikle düzeltilebilecek diğer türde değişiklikler olabilir.
Örnek olması açısından, Git'in boşluk değişikliğini halledemediğini ve bunu kendimizin düzeltmesi gerektiğini varsayalım.

Aslında yapmamız gereken şey, birleştirmeye çalıştığımız dosyayı, birleştirmeden önce bir `dos2unix` programından geçirmektir.
Peki, bunu nasıl yapabiliriz?

Öncelikle, çakışma durumuna geliyoruz.
Sonra, dosyanın kendi sürümümüzün, onların (birleştirmek istediğimiz dalın) sürümünün ve ortak sürümün (her iki tarafın da dallandığı yerden) kopyalarını almak istiyoruz.
Daha sonra, onların tarafını veya kendi tarafımızı düzeltip sadece bu tek dosya için birleştirmeyi tekrar denemek istiyoruz.

Üç dosya sürümünü almak aslında oldukça kolaydır.
Git, bu sürümlerin hepsini izlemde `stages` altında, her birini kendiyle ilişkilendirilmiş numaralara sahip olmak üzede saklar.
1: ortak öncel, 2: sizin sürümünüz, ve 3: birleştirmeyi yaptığınız sürüm olan `MERGE_HEAD` 'den gelir.

Çakışan dosyanın her bir sürümünü `git show` komutunu ve özel bir sözdizimini kullanarak çıkarabilirsiniz.

[source,console]
----
$ git show :1:hello.rb > hello.common.rb
$ git show :2:hello.rb > hello.ours.rb
$ git show :3:hello.rb > hello.theirs.rb
----

Daha detaylı bir şekilde ilerlemek isterseniz, `ls-files -u` tesisat komutunu kullanarak bu dosyaların her biri için Git bloblarının gerçek SHA-1'lerini alabilirsiniz.

[source,console]
----
$ git ls-files -u
100755 ac51efdc3df4f4fd328d1a02ad05331d8e2c9111 1	hello.rb
100755 36c06c8752c78d2aff89571132f3bf7841a7b5c3 2	hello.rb
100755 e85207e04dfdd5eb0a1e9febbc67fd837c44a1cd 3	hello.rb
----

`:1:hello.rb`, bu blobun SHA-1'ini aramak için kullanılan bir kısaltmadır.

Artık çalışma dizinimizde her üç izlem'in de içeriğine sahip olduğumuza göre, boşluk sorununu çözmek için onların tarafını elle düzeltebilir ve az bilinen `git merge-file` komutunu kullanarak dosyayı yeniden birleştirebiliriz.

[source,console]
----
$ dos2unix hello.theirs.rb
dos2unix: converting file hello.theirs.rb to Unix format ...

$ git merge-file -p \
    hello.ours.rb hello.common.rb hello.theirs.rb > hello.rb

$ git diff -b
diff --cc hello.rb
index 36c06c8,e85207e..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,8 -1,7 +1,8 @@@
  #! /usr/bin/env ruby

 +# prints out a greeting
  def hello
-   puts 'hello world'
+   puts 'hello mundo'
  end

  hello()
----

Bu noktada dosyayı güzel bir şekilde birleştirdik.
Aslında bu, boşluk değişikliklerini doğrudan yoksaymak yerine, gerçekte onları birleştirme öncesinde düzelttiği için `ignore-space-change` seçeneğinden daha iyi çalışır.
`ignore-space-change` birleştirmesinde, DOS satır sonlarına sahip olan satırlar biraz kafa karıştırıcıdır.

Bu katkıyı işlemeden önce, son bir kontrol amacıyla, gerçekte hangi tarafın hangi değişiklikleri yaptığını görmek isterseniz; katkılamak üzere çalışma dizinizde olup birleştirme sonucu olarak katkılayacağınız çalışmayı bu izlemlerdekilerle kıyaslamak için `git diff` komutunu kullanabilirsiniz.
Şimdi hepsini deneyelim.

Sonucunuzu birleştirmeden önce dalınızdaki son durumuyla karşılaştırmak, diğer bir deyişle birleştirmenin ne tür değişiklikler getirdiğini görmek için `git diff --ours` komutunu çalıştırabilirsiniz.

[source,console]
----
$ git diff --ours
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index 36c06c8..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -2,7 +2,7 @@

 # prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Bu şekilde, dalımızda olup biteni, bu dosyaya bu birleştirmeyle tanıttığımız şeyin, o tek satırı değiştirmek olduğunu kolaylıkla görebiliriz.


Birleştirmenin sonucunun, onların tarafındakinden nasıl farklı olduğunu görmek istiyorsak, `git diff --theirs` komutunu çalıştırabiliriz.
Bu ve aşağıdaki örnekte, boşlukları çıkarmak için `-b' kullanmamız gerekiyor çünkü onu temizlenmiş 'hello.theirs.rb' dosyamızla değil, Git'tekiyle karşılaştırıyoruz.

[source,console]
----
$ git diff --theirs -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index e85207e..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,5 +1,6 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
   puts 'hello mundo'
 end
----

Son olarak, dosyanın her iki taraftan da nasıl değiştiğini `git diff --base` ile görebilirsiniz.

[source,console]
----
$ git diff --base -b
* Unmerged path hello.rb
diff --git a/hello.rb b/hello.rb
index ac51efd..44d0a25 100755
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,8 @@
 #! /usr/bin/env ruby

+# prints out a greeting
 def hello
-  puts 'hello world'
+  puts 'hello mundo'
 end

 hello()
----

Bu noktada, manuel birleştirmeyi yapmak için oluşturduğumuz, ancak artık ihtiyaç duymadığımız ek dosyaları temizlemek için `git clean` komutunu kullanabiliriz.

[source,console]
----
$ git clean -f
Removing hello.common.rb
Removing hello.ours.rb
Removing hello.theirs.rb
----

[[_checking_out_conflicts]]
===== Çakışmaları Kontrol Etme

Belki bu aşamada bir nedenle çözümden memnun değilizdir. Ya da belki bir veya her iki tarafı manuel olarak düzenlemek çok da iyi çalışmamıştır ve daha fazla bağlam gerekmektedir.

Örneği biraz değiştirelim.
Bu örnekte, her birinde birkaç katkı olan iki uzun ömürlü dalımız var, ancak birleştirildiğinde meşru bir içerik çakışması oluşturuyorlar.

[source,console]
----
$ git log --graph --oneline --decorate --all
* f1270f7 (HEAD, master) update README
* 9af9d3b add a README
* 694971d update phrase to hola world
| * e3eb223 (mundo) add more tests
| * 7cff591 add testing script
| * c3ffff1 changed text to hello mundo
|/
* b7dcc89 initial hello world code
----

Şimdi, yalnızca `master` dalında bulunan üç benzersiz katkımız var ve diğer üçü de `mundo` dalında bulunuyor.
`mundo` dalını birleştirmeye çalışırsak, bir çakışma alırız.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Automatic merge failed; fix conflicts and then commit the result.
----

Çakışmanın ne olduğunu görmek istiyoruz.
Dosyayı açarsak, şuna benzer bir şey göreceğiz:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< HEAD
  puts 'hola world'
=======
  puts 'hello mundo'
>>>>>>> mundo
end

hello()
----

Her iki tarafın da bu dosyaya içerik eklemiş, ancak bazı katkılar bu çakışmaya sebep olan dosyayı değiştirmiştir.

Şimdi, bu çatışmayı nasıl düzelteceğiniz tam olarak açık değilse, kullanabileceğiniz birkaç aracı keşfedelim.
Belki de bu çatışmayı nasıl çözeceğiniz tam olarak belli değil ve daha fazla bağlama ihtiyacınız var.

Yararlı bir araç, `git checkout` komutuna eklenen `--conflict` seçeneğidir.
Bu komut dosyayı yeniden kontrol eder ve çakışma işaretlerini değiştirir.
İşaretleri sıfırlamak ve yeniden çözmeyi denemek istiyorsanız, bu faydalı olabilir.

`--conflict` seçeneğine `diff3` veya `merge` (varsayılan) değerlerinden herhangi birini ekleyebilirsiniz.
Eğer `diff3` 'ü eklerseniz, Git biraz farklı bir çatışma işareti versiyonu kullanır; size sadece `ours` (bizimki) ve `theirs` (onlarınki) versiyonlarını değil, aynı zamanda daha fazla bağlam için `base` versiyonunu da içerir.

[source,console]
----
$ git checkout --conflict=diff3 hello.rb
----

Bunu çalıştırdıktan sonra, dosya şuna benzer olacaktır:

[source,ruby]
----
#! /usr/bin/env ruby

def hello
<<<<<<< ours
  puts 'hola world'
||||||| base
  puts 'hello world'
=======
  puts 'hello mundo'
>>>>>>> theirs
end

hello()
----

Eğer bu formatı begendiyseniz, gelecekteki birleştirme çakışmalarında varsayılan olarak ayarlamak için `merge.conflictstyle` ayarını `diff3` olarak değiştirebilirsiniz.

[source,console]
----
$ git config --global merge.conflictstyle diff3
----

`git checkout` komutu ayrıca `--ours` ve `--theirs` seçeneklerini alabilir, bu da bir tarafı seçmek veya diğerini tamamen birleştirmeden önce seçmenin çok hızlı bir yoludur.

Bu, özellikle sadece bir tarafı seçmek istediğiniz ikili (binary) dosya çatışmaları veya başka bir dalda belirli dosyaları birleştirmek istediğiniz durumlar için kullanışlı olabilir; birleştirmeyi yapabilir ve ardından katkıyı işlemeden önce belirli dosyaları bir taraftan veya diğerinden seçebilirsiniz.

[[_merge_log]]
===== Merge Günlüğü

Git birleştirme çatışmalarını çözerken yararlı bir başka araç da `git log` komutudur.
Bu komut çatışmalara katkıda bulunan faktörleri anlamanıza yardımcı olabilir.
Bazen iki geliştirme hattının aynı kod bölgesine dokunmasının nedenlerini hatırlamak için, biraz geçmişi gözden geçirmek gerçekten yardımcı olabilir.

Bu birleştirmeye dahil olan her iki dalın da içerdiği benzersiz tüm katkıların tam bir listesini almak için, <<ch07-git-tools#_triple_dot>> sözdizimini kullanabiliriz.

[source,console]
----
$ git log --oneline --left-right HEAD...MERGE_HEAD
< f1270f7 update README
< 9af9d3b add a README
< 694971d update phrase to hola world
> e3eb223 add more tests
> 7cff591 add testing script
> c3ffff1 changed text to hello mundo
----

Bu, her katkının hangi geliştirme hattında olduğuyla birlikte, sürece dahil olan toplam altı katkının güzel bir listesidir.

Ancak, bunu çok daha spesifik bir bağlama sahip olması için biraz daha basitleştirebiliriz.
`git log` komutuna `--merge` seçeneğini eklersek, çakışmada olan bir dosyayı değiştiren katkıları gösterecektir.

[source,console]
----
$ git log --oneline --left-right --merge
< 694971d update phrase to hola world
> c3ffff1 changed text to hello mundo
----

Eğer `-p` seçeneği ile çalıştırırsanız, çakışmaya neden olan dosyalara ilişkin farklılıkları alırsınız.
Bu, bir şeyin neden çakıştığını anlamanıza ve daha akıllıca nasıl çözeceğinize dair ihtiyacınız olan bağlamı hızlı bir şekilde sağlamak için *gerçekten* faydalı olabilir.

===== Birleşik Fark Formatı

Git, başarılı olan her birleştirmeyi izleme alır; bu nedenle çakışma durumunda `git diff` komutunu çalıştırdığınızda sadece hala çakışma durumunda olanları alırsınız. 
Bu, çözmeniz gerekenleri görmek için faydalı olabilir.

Birleştirme çakışmasının hemen ardından `git diff` komutunu çalıştırdığınızda, size benzersiz bir formatta bir fark çıktısı verecektir.

[source,console]
----
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,11 @@@
  #! /usr/bin/env ruby

  def hello
++<<<<<<< HEAD
 +  puts 'hola world'
++=======
+   puts 'hello mundo'
++>>>>>>> mundo
  end

  hello()
----

The format is called ``Combined Diff'' and gives you two columns of data next to each line.
The first column shows you if that line is different (added or removed) between the ``ours'' branch and the file in your working directory and the second column does the same between the ``theirs'' branch and your working directory copy.

So in that example you can see that the `<<<<<<<` and `>>>>>>>` lines are in the working copy but were not in either side of the merge.
This makes sense because the merge tool stuck them in there for our context, but we're expected to remove them.

If we resolve the conflict and run `git diff` again, we'll see the same thing, but it's a little more useful.

[source,console]
----
$ vim hello.rb
$ git diff
diff --cc hello.rb
index 0399cd5,59727f0..0000000
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

This shows us that ``hola world'' was in our side but not in the working copy, that ``hello mundo'' was in their side but not in the working copy and finally that ``hola mundo'' was not in either side but is now in the working copy.
This can be useful to review before committing the resolution.

You can also get this from the `git log` for any merge to see how something was resolved after the fact.
Git will output this format if you run `git show` on a merge commit, or if you add a `--cc` option to a `git log -p` (which by default only shows patches for non-merge commits).

[source,console]
----
$ git log --cc -p -1
commit 14f41939956d80b9e17bb8721354c33f8d5b5a79
Merge: f1270f7 e3eb223
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Sep 19 18:14:49 2014 +0200

    Merge branch 'mundo'

    Conflicts:
        hello.rb

diff --cc hello.rb
index 0399cd5,59727f0..e1d0799
--- a/hello.rb
+++ b/hello.rb
@@@ -1,7 -1,7 +1,7 @@@
  #! /usr/bin/env ruby

  def hello
-   puts 'hola world'
 -  puts 'hello mundo'
++  puts 'hola mundo'
  end

  hello()
----

[[_undoing_merges]]
==== Undoing Merges

Now that you know how to create a merge commit, you'll probably make some by mistake.
One of the great things about working with Git is that it's okay to make mistakes, because it's possible (and in many cases easy) to fix them.

Merge commits are no different.
Let's say you started work on a topic branch, accidentally merged it into `master`, and now your commit history looks like this:

.Accidental merge commit
image::images/undomerge-start.png[Accidental merge commit.]

There are two ways to approach this problem, depending on what your desired outcome is.

===== Fix the references

If the unwanted merge commit only exists on your local repository, the easiest and best solution is to move the branches so that they point where you want them to.
In most cases, if you follow the errant `git merge` with `git reset --hard HEAD~`, this will reset the branch pointers so they look like this:

.History after `git reset --hard HEAD~`
image::images/undomerge-reset.png[History after `git reset --hard HEAD~`.]

We covered `reset` back in <<ch07-git-tools#_git_reset>>, so it shouldn't be too hard to figure out what's going on here.
Here's a quick refresher: `reset --hard` usually goes through three steps:

. Move the branch HEAD points to.
  In this case, we want to move `master` to where it was before the merge commit (`C6`).
. Make the index look like HEAD.
. Make the working directory look like the index.

The downside of this approach is that it's rewriting history, which can be problematic with a shared repository.
Check out <<ch03-git-branching#_rebase_peril>> for more on what can happen; the short version is that if other people have the commits you're rewriting, you should probably avoid `reset`.
This approach also won't work if any other commits have been created since the merge; moving the refs would effectively lose those changes.

[[_reverse_commit]]
===== Reverse the commit

If moving the branch pointers around isn't going to work for you, Git gives you the option of making a new commit which undoes all the changes from an existing one.
Git calls this operation a ``revert'', and in this particular scenario, you'd invoke it like this:

[source,console]
----
$ git revert -m 1 HEAD
[master b1d8379] Revert "Merge branch 'topic'"
----

The `-m 1` flag indicates which parent is the ``mainline'' and should be kept.
When you invoke a merge into `HEAD` (`git merge topic`), the new commit has two parents: the first one is `HEAD` (`C6`), and the second is the tip of the branch being merged in (`C4`).
In this case, we want to undo all the changes introduced by merging in parent #2 (`C4`), while keeping all the content from parent #1 (`C6`).

The history with the revert commit looks like this:

.History after `git revert -m 1`
image::images/undomerge-revert.png[History after `git revert -m 1`.]

The new commit `^M` has exactly the same contents as `C6`, so starting from here it's as if the merge never happened, except that the now-unmerged commits are still in `HEAD`'s history.
Git will get confused if you try to merge `topic` into `master` again:

[source,console]
----
$ git merge topic
Already up-to-date.
----

There's nothing in `topic` that isn't already reachable from `master`.
What's worse, if you add work to `topic` and merge again, Git will only bring in the changes _since_ the reverted merge:

.History with a bad merge
image::images/undomerge-revert2.png[History with a bad merge.]

The best way around this is to un-revert the original merge, since now you want to bring in the changes that were reverted out, *then* create a new merge commit:

[source,console]
----
$ git revert ^M
[master 09f0126] Revert "Revert "Merge branch 'topic'""
$ git merge topic
----

.History after re-merging a reverted merge
image::images/undomerge-revert3.png[History after re-merging a reverted merge.]

In this example, `M` and `^M` cancel out.
`^^M` effectively merges in the changes from `C3` and `C4`, and `C8` merges in the changes from `C7`, so now `topic` is fully merged.

==== Other Types of Merges

So far we've covered the normal merge of two branches, normally handled with what is called the ``recursive'' strategy of merging.
There are other ways to merge branches together however.
Let's cover a few of them quickly.

===== Our or Theirs Preference

First of all, there is another useful thing we can do with the normal ``recursive'' mode of merging.
We've already seen the `ignore-all-space` and `ignore-space-change` options which are passed with a `-X` but we can also tell Git to favor one side or the other when it sees a conflict.

By default, when Git sees a conflict between two branches being merged, it will add merge conflict markers into your code and mark the file as conflicted and let you resolve it.
If you would prefer for Git to simply choose a specific side and ignore the other side instead of letting you manually resolve the conflict, you can pass the `merge` command either a `-Xours` or `-Xtheirs`.

If Git sees this, it will not add conflict markers.
Any differences that are mergeable, it will merge.
Any differences that conflict, it will simply choose the side you specify in whole, including binary files.

If we go back to the ``hello world'' example we were using before, we can see that merging in our branch causes conflicts.

[source,console]
----
$ git merge mundo
Auto-merging hello.rb
CONFLICT (content): Merge conflict in hello.rb
Resolved 'hello.rb' using previous resolution.
Automatic merge failed; fix conflicts and then commit the result.
----

However if we run it with `-Xours` or `-Xtheirs` it does not.

[source,console]
----
$ git merge -Xours mundo
Auto-merging hello.rb
Merge made by the 'recursive' strategy.
 hello.rb | 2 +-
 test.sh  | 2 ++
 2 files changed, 3 insertions(+), 1 deletion(-)
 create mode 100644 test.sh
----

In that case, instead of getting conflict markers in the file with ``hello mundo'' on one side and ``hola world'' on the other, it will simply pick ``hola world''.
However, all the other non-conflicting changes on that branch are merged successfully in.

This option can also be passed to the `git merge-file` command we saw earlier by running something like `git merge-file --ours` for individual file merges.

If you want to do something like this but not have Git even try to merge changes from the other side in, there is a more draconian option, which is the ``ours'' merge _strategy_.
This is different from the ``ours'' recursive merge _option_.

This will basically do a fake merge.
It will record a new merge commit with both branches as parents, but it will not even look at the branch you're merging in.
It will simply record as the result of the merge the exact code in your current branch.

[source,console]
----
$ git merge -s ours mundo
Merge made by the 'ours' strategy.
$ git diff HEAD HEAD~
$
----

You can see that there is no difference between the branch we were on and the result of the merge.

This can often be useful to basically trick Git into thinking that a branch is already merged when doing a merge later on.
For example, say you branched off a `release` branch and have done some work on it that you will want to merge back into your `master` branch at some point.
In the meantime some bugfix on `master` needs to be backported into your `release` branch.
You can merge the bugfix branch into the `release` branch and also `merge -s ours` the same branch into your `master` branch (even though the fix is already there) so when you later merge the `release` branch again, there are no conflicts from the bugfix.

include::subtree-merges.asc[]
