[[_git_stashing]]
=== Saklama ve Silme

Çoğu zaman, projenizin bir kısmında çalışırken, işler karışmış olabilir ve bir süre başka bir şey üzerinde çalışmak için dal değiştirmek isteyebilirsiniz.
Ancak sorun şudur ki, daha sonra tamamlamak için geri döneceğiniz için yarım kalmış bir işi katkılamak istemezsiniz.
Bu sorunun çözümü, `git stash` komutundadır.

`stash` komutu, çalışma dizininizin ham durumunu  - yani, değiştirilmiş izlenen dosyalarınızı ve izlem değişikliklerinizi - alır ve bunu her zaman yeniden (hatta farklı bir dalda bile) uygulayabileceğiniz tamamlanmamış değişiklikler yığınına olarak kaydeder.

[NOT]
.`git stash push`'a geçiş
====
Ekim 2017'nin sonlarına doğru, Git posta listesinde `git stash save` komutunun kaldırılıp, alternatif olarak yerine zaten mevcut olan `git stash push` komutunun kullanılması üzerine kapsamlı bir tartışma yapılmıştır.
Bunun ana nedeni, `git stash push` komutunun, `git stash save` tarafından desteklenmeyen _pathspecs_ gizleme seçeneğini sunmasıdır.

`git stash save` yakın zamanda ortadan kalkmayacak, bu yüzden birdenbire kaybolacağından endişelenmeyin.
Ancak yeni işlevsellik için `push` alternatifine geçmeye başlamak isteyebilirsiniz.
====

==== Çalışmanızı Saklama

Saklamayı (stashing) göstermek için projenize girip birkaç dosyada çalışmaya başlayacak ve belki de değişikliklerden birini sahneye koyacaksınız.
`git status` komutunu çalıştırırsanız, ham durumunuzu görebilirsiniz:

[source,console]
----
$ git status
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

Şimdi dal değiştirmek istiyorsunuz, ancak üzerinde çalıştığınız şeyleri henüz kaydetmek istemiyorsunuz, bu yüzden değişiklikleri saklayacaksınız.
Yığınınıza yeni bir saklama eklemek için `git stash` veya `git stash push` komutunu çalıştırın:

[source,console]
----
$ git stash
Saved working directory and index state \
  "WIP on master: 049d078 added the index file"
HEAD is now at 049d078 added the index file
(To restore them type "git stash apply")
----

Şimdi çalışma dizininizin temizlendiğini görebilirsiniz:

[source,console]
----
$ git status
# On branch master
nothing to commit, working directory clean
----

Bu noktada, dal değiştirebilir ve başka bir yerde çalışabilirsiniz; değişiklikleriniz yığınınızda saklanmaktadır.
Hangi saklamaları depoladığınızı görmek için `git stash list` komutunu kullanabilirsiniz:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
----

Daha önce zaten iki saklama yapılmış olduğu için, şu an üç farklı saklanmış çalışmaya erişiminiz var.
Yeni sakladığınızı tekrar uygulamak için orijinal saklama komutunun yardım çıktısında gösterilen komutu çalıştırabilirsiniz: `git stash apply`
Eski saklamalardan birini uygulamak isterseniz, onu şu şekilde adlandırarak belirtebilirsiniz: `git stash apply stash@{2}`.
Bir saklama belirtmezseniz, Git en son saklamayı varsayarak, doğrudan onu uygular:

[source,console]
----
$ git stash apply
On branch master
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   index.html
	modified:   lib/simplegit.rb

no changes added to commit (use "git add" and/or "git commit -a")
----

Görebileceğiniz gibi, Git, saklamayı kaydettiğinizde geri aldığınız dosyaları yeniden getirdi.
Saklamayı başlattığınızda temiz bir çalışma diziniz vardı ve onu kaydettiğiniz aynı dalda uygulamaya çalıştınız.
Temiz bir çalışma dizinine sahip olmak ve onu aynı dala uygulamak, bir saklama işlemini başarıyla uygulamak için gerekli değildir.
Bir saklamayı bir dalda kaydedip daha sonra başka bir dala geçebilir ve değişiklikleri yeniden uygulamayı deneyebilirsiniz.
Ayrıca, bir saklamayı uygularken çalışma dizinizde değiştirilmiş ve katkılanmamış dosyalara sahip olabilirsiniz - Git, bir şeylerin artık temiz bir şekilde uygulanmadığında birleştirme çakışmaları verir.

Dosyalarınızdaki değişiklikler tekrar uygulandı, ancak önce izleme aldığınız dosya yeniden izlemlenmedi.
Bunu yapmak için, `git stash apply` komutunu `--index` seçeneği ile çalıştırmalısınız; bu seçenek komuta, izlemlediğiniz değişiklikleri tekrar uygulamayı denemesini söyler.
Öncekini yapmak yerine, bunu çalıştırsaydınız, orijinal konumunuza geri dönecektiniz:

[source,console]
----
$ git stash apply --index
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb
----

`apply` (uygula) seçeneği sadece saklanmış çalışmayı uygulamaya çalışır ama  onu yığınınızda tutmaya devam edersiniz.
Onu kaldırmak için, kaldırmak istediğiniz saklamanın adıyla `git stash drop` komutunu çalıştırabilirsiniz:

[source,console]
----
$ git stash list
stash@{0}: WIP on master: 049d078 added the index file
stash@{1}: WIP on master: c264051 Revert "added file_size"
stash@{2}: WIP on master: 21d80a5 added number to log
$ git stash drop stash@{0}
Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)
----

Ayrıca, saklamayı uygulamak ve ardından hemen yığınınızdan kaldırmak için `git stash pop` komutunu da çalıştırabilirsiniz.

==== Yaratıcı Saklama

Faydalı bulabileceğiniz bir kaç farklı saklama seçeneği daha bulunmaktadır.
Oldukça popüler olan ilk seçenek: `git stash` komutuna `--keep-index` seçeneği eklemektir.
Bu, Git'e oluşturulan saklamaya tüm izlemlenmiş içeriği dahil etmenin yanı sıra, aynı anda onları izlem içinde bırakmasını da söyler.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb

$ git stash --keep-index
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
M  index.html
----

"Saklama" ile yapmak isteyebileceğiniz başka yaygın bir şey, izlenen dosyaların yanı sıra izlenmeyen dosyaları da saklamaktır.
Varsayılan olarak, `git stash`, yalnızca değiştirilmiş ve izlemlenmiş (takipte olan - tracked) dosyaları saklar.
`--include-untracked` veya `-u`'yi belirtirseniz, Git, oluşturulan saklamaya izlenmeyen dosyaları da dahil eder.
Ancak, saklamaya izlenmeyen dosyaları dahil etmek, _yoksayılan_ dosyaları da doğrudan dahil etmez; yoksayılan dosyaları da dahil etmek için `--all` (veya sadece `-a`) kullanın.

[source,console]
----
$ git status -s
M  index.html
 M lib/simplegit.rb
?? new-file.txt

$ git stash -u
Saved working directory and index state WIP on master: 1b65b17 added the index file
HEAD is now at 1b65b17 added the index file

$ git status -s
$
----

Son olarak, `--patch` bayrağını belirtirseniz, Git değiştirilmiş her şeyi saklamaz ancak bunun yerine size etkileşimli olarak hangi değişiklikleri saklamak istediğinizi ve hangilerini çalışma dizinizde tutmak istediğinizi sorar.

[source,console]
----
$ git stash --patch
diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index 66d332e..8bb5674 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -16,6 +16,10 @@ class SimpleGit
         return `#{git_cmd} 2>&1`.chomp
       end
     end
+
+    def show(treeish = 'master')
+      command("git show #{treeish}")
+    end

 end
 test
Stash this hunk [y,n,q,a,d,/,e,?]? y

Saved working directory and index state WIP on master: 1b65b17 added the index file
----

==== Bir "Saklama"dan Dal Oluşturma

Eğer bir çalışmanızı saklarsanız, bir süre beklerseniz ve sonra çalışmaya devam etmek için sakladığınız işin olduğu dala geri dönerseniz, çalışmanızı tekrar uygulamakta bir problem yaşayabilirsiniz.
Eğer uygulama işlemi daha sonra değiştirdiğiniz bir dosyayı değiştirmeye çalışırsa, birleştirme çakışması alırsınız ve bunu çözmeniz gerekir.
Saklanmış değişiklikleri tekrar test etmek için daha kolay bir yol isterseniz, `git stash branch <yeni dal adı>` komutunu çalıştırabilirsiniz. 
Bu komut, seçtiğiniz dal adıyla sizin için yeni bir dal oluşturur, çalışmanızı saklarken üzerinde bulunduğunuz katkıya gider, çalışmanızı oraya yeniden uygular ve başarıyla uygulanırsa saklamayı kaldırır.

[source,console]
----
$ git stash branch testchanges
M	index.html
M	lib/simplegit.rb
Switched to a new branch 'testchanges'
On branch testchanges
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	modified:   index.html

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   lib/simplegit.rb

Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)
----

Bu, saklanmış işleri kolayca kurtarmak ve bunu yeni bir dalda uygulamak için güzel bir kısayoldur.

[[_git_clean]]
==== Çalışma Dizininizi Temizlemek

Finally, you may not want to stash some work or files in your working directory, but simply get rid of them; that's what the `git clean` command is for.

Some common reasons for cleaning your working directory might be to remove cruft that has been generated by merges or external tools or to remove build artifacts in order to run a clean build.

You'll want to be pretty careful with this command, since it's designed to remove files from your working directory that are not tracked.
If you change your mind, there is often no retrieving the content of those files.
A safer option is to run `git stash --all` to remove everything but save it in a stash.

Assuming you do want to remove cruft files or clean your working directory, you can do so with `git clean`.
To remove all the untracked files in your working directory, you can run `git clean -f -d`, which removes any files and also any subdirectories that become empty as a result.
The `-f` means 'force' or ``really do this,'' and is required if the Git configuration variable `clean.requireForce` is not explicitly set to false.

If you ever want to see what it would do, you can run the command with the `--dry-run` (or `-n`) option, which means ``do a dry run and tell me what you _would_ have removed''.

[source,console]
----
$ git clean -d -n
Would remove test.o
Would remove tmp/
----

By default, the `git clean` command will only remove untracked files that are not ignored.
Any file that matches a pattern in your `.gitignore` or other ignore files will not be removed.
If you want to remove those files too, such as to remove all `.o` files generated from a build so you can do a fully clean build, you can add a `-x` to the clean command.

[source,console]
----
$ git status -s
 M lib/simplegit.rb
?? build.TMP
?? tmp/

$ git clean -n -d
Would remove build.TMP
Would remove tmp/

$ git clean -n -d -x
Would remove build.TMP
Would remove test.o
Would remove tmp/
----

If you don't know what the `git clean` command is going to do, always run it with a `-n` first to double check before changing the `-n` to a `-f` and doing it for real.
The other way you can be careful about the process is to run it with the `-i` or ``interactive'' flag.

This will run the clean command in an interactive mode.

[source,console]
----
$ git clean -x -i
Would remove the following items:
  build.TMP  test.o
*** Commands ***
    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit
    6: help
What now>
----

This way you can step through each file individually or specify patterns for deletion interactively.

[NOTE]
====
There is a quirky situation where you might need to be extra forceful in asking Git to clean your working directory.
If you happen to be in a working directory under which you've copied or cloned other Git repositories (perhaps as submodules), even `git clean -fd` will refuse to delete those directories.
In cases like that, you need to add a second `-f` option for emphasis.
====
