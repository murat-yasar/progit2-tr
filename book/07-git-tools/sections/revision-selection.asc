[[_revision_selection]]
=== Düzeltme Seçimi

Git, bir veya birkaç katkı veya katkı aralığına birkaç şekilde atıfta bulunmanızı sağlar. Bunlar her zaman açık olmayabilir, ancak bilmeniz faydalı olabilir.

==== Tekli Düzeltmeler

Herhangi tek bir katkıyı 40 karakterlik tam bir SHA-1 karmasıyla (hash) gösterebilirsiniz, ancak katkıları daha insan dostu yollarla da belirtebilirsiniz.
Bu bölüm, herhangi bir katkıyı belirtmek için kullanabileceğiniz çeşitli yolları açıklar.

==== Kısa SHA-1

Bir katkıyı belirtmek için SHA-1 karmasının ilk birkaç karakterini yazarsanız, yazdığınız karma en az dört karakter uzunluğunda ve belirsiz olmadığı sürece, Git hangi katkıya atıfta bulunduğunuzu anlayacak kadar akıllıdır. Başka bir deyişle, nesne veritabanında aynı önek ile başlayan başka bir nesne olmadığı müddetçe sorun yaşamazsınız.

Örneğin, belirli bir işlev eklediğinizi bildiğiniz bir katkıyı incelemek için, ilk önce `git log` komutunu çalıştırarak o katkıyı bulabilirsiniz:

[source,console]
----
$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
----

Diyelim ki, SHA-1 özetinin `1c002dd...` ile başladığı bir katkıyla ilgileniyorsunuz.
Bu katkıyı incelemek için aşağıdaki `git show` çeşitlemelerinden herhangi birini kullanabilirsiniz (kısa versiyonların belirsiz olmadığı varsayılmaktadır):

[source,console]
----
$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
$ git show 1c002dd4b536e7479f
$ git show 1c002d
----

Git, SHA-1 değerleriniz için kısa, benzersiz bir kısaltma bulabilir.
`git log` komutuna `--abbrev-commit` seçeneğini eklerseniz, çıktı daha kısa değerler kullanacak ancak bunları benzersiz tutacaktır; SHA-1'in belirsiz olmaması (benzersiz olması) için, varsayılan olarak yedi karakter kullanır ancak bu onu daha uzun hale getirir:

[source,console]
----
$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
----

Genellikle, bir projenin içinde benzersiz olması için sekiz ila on karakter yeterlidir.
Örneğin, - Şubat 2019 itibarıyla 875.000'den fazla katkı ve neredeyse yedi milyon nesne içeren - oldukça büyük bir proje olan Linux çekirdeğinde, SHA-1'leri ilk 12 karakteri aynı olan hiçbir nesne bulunmuyor.

[NOT]
.SHA-1 HAKKINDA KISA BİR NOT
====

Birçok insan, rastgele bir olay sonucu, repolarında birbirinden farklı iki nesnenin aynı SHA-1 değerine sahip olabileceğinden endişelenir.
Peki sonra ne olur?

Eğer repoya daha önceden işlenmiş _farklı_ bir nesnenin SHA-1 değerine sahip yeni bir nesne eklerseniz, Git önceki nesneyi zaten Git veritabanınızda görecek, bu nesnenin zaten yazıldığını varsayacak ve onu yeniden kullanacaktır.
Bir noktada o nesneye geçmeye çalışırsanız, her zaman ilk nesnenin verisini alacaksınız.

Ancak, bu senaryonun gerçekleşme ihtimalinin, imkansıza yakın derecede olanaksız olduğunun farkında olmalısınız.
SHA-1 özeti 20 bayt veya 160 bit'tir.
Bu eşleşme olasılığının %50 olması için gerekli rastgele özetlenmiş nesne sayısı yaklaşık 2^80 (2 üzeri 80) civarındadır
(çarpışma olasılığını belirleme formülü `p = (n(n-1)/2) * (1/2^160)`). 
2 üzeri 80 yaklaşık olarak 1,2 x 10^24 veya kelimelere dökersek "milyon kere milyar kere milyar"dır.
Bu da dünyadaki kum tanelerinin toplam sayısının yaklaşık 1,200 katıdır.

İşte bir SHA-1 çarpışmasını elde etmek için gerekenleri anlamanıza yardımcı olacak bir başka örnek:
Dünyadaki 6,5 milyar insanın hepsi programlama yapıyor olsaydı ve bunların her biri, Linux çekirdeğine saniyede bir katkı işleyip (saniyede 6,5 milyon Git nesnesi) bunları devasa bir Git reposuna itseydi; bu repoda bir tek SHA-1 nesnesinin çarpışma olasılığının %50 olması, yaklaşık 2 yıl sürerdi.
Bu nedenle, bir SHA-1 çarpışmasının gerçekleşme ihtimali, programlama ekibinizin tüm üyelerinin, aynı gece, farklı yerlerde, farklı şeylerle ilgilenirken, aniden kurtlar tarafından saldırıya uğraması ve öldürülmesinden daha düşüktür.

====

[[_branch_references]]
==== Dal Referansları

Belirli bir katkıya başvurmanın basit bir yolu, o dalın uç noktasındaki bir katkı olduğunda; bu durumda, bir katkı başvurusunu bekleyen herhangi bir Git komutunda sadece dal adını kullanabilirsiniz.
Örneğin, bir daldaki son katkı nesnesini incelemek istiyorsanız, `topic1` dalının `ca82a6d...` katkısına işaret ettiğini varsayarsak, aşağıdaki komutlar eşdeğerdir:

[source,console]
----
$ git show ca82a6dff817ec66f44342007202690a93763949
$ git show topic1
----

Bir dalın hangi SHA-1'e işaret ettiğini görmek istiyorsanız veya bu örneklerden herhangi birinin SHA-1'ler açısından neye denk geldiğini görmek istiyorsanız, `rev-parse` adlı bir Git aracını kullanabilirsiniz.
Daha fazla bilgi için <<ch10-git-internals#ch10-git-internals>> adresine bakabilirsiniz; temelde, `rev-parse` daha düşük düzeyli işlemler için var ve günlük işlemlerde kullanılmak üzere tasarlanmamıştır.
Ancak, bazen gerçekte ne olduğunu görmek gerektiğinde yardımcı olabilir.
Burada dalınız üzerinde `rev-parse` çalıştırabilirsiniz.

[source,console]
----
$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
----

[[_git_reflog]]
==== Referans Günlüğü (Reflog) Kısa Adları

Git'in arka planda çalışırken yaptığı şeylerden biri, "reflog" olarak adlandırılan, HEAD ve dal referanslarınızın son birkaç ay boyunca nerede olduğunu kaydettiği bir günlük tutmaktır.

Referans günlügünüzü `git reflog` komutunu kullanarak görebilirsiniz:

[source,console]
----
$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
----

Herhangi bir nedenle dal ucu güncellendiğinde, Git bu bilgiyi geçici bir geçmişte sizin için saklar.
Reflog verilerinizi eski katkılara başvurmak için de kullanabilirsiniz.
Örneğin, repo ucunuzun beş önceki değerini görmek istiyorsanız, reflog çıktısında gördüğünüz `@{5}` referansını kullanabilirsiniz:

[source,console]
----
$ git show HEAD@{5}
----

Bu sözdizimini ayrıca bir dalın belirli bir süre önce nerede olduğunu görmek için de kullanabilirsiniz.
Örneğin, `master` dalınızın dün nerede olduğunu görmek için şunu yazabilirsiniz:

[source,console]
----
$ git show master@{yesterday}
----

Bu, `master` dalınızın ucunun dün nerede olduğunu gösterir.
Bu teknik, hala referans günlüğünüzde olan veriler için çalışır, bu nedenle birkaç aydan daha eski katkıları aramak için kullanamazsınız.

`git log` çıktısı gibi biçimlendirilmiş referans günlüğü bilgilerini görmek için `git log -g` komutunu çalıştırabilirsiniz:

[source,console]
----
$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon <schacon@gmail.com>
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

Reflog bilgilerinin kesinlikle yerel olduğunu bilmelisinizi - yalnızca _sizin kendi reponuzda yaptığınız_ işlemlerin günlüğüdür.
Referanslar, başkasının repo kopyasında aynı olmayacaktır; ayrıca bir repoyu başlangıçta klonladıktan hemen sonra, henüz repoda herhangi bir etkinlik olmadığından boş bir referans günlüğünüz olacaktır.
`git show HEAD@{2.months.ago}` komutunu çalıştırmak; eğer projeyi en az iki ay önce kopyaladıysanız, yalnızca eşleşen katkıyı gösterecektir; eğer bundan daha yeni bir tarihte kopyaladıysanız, yalnızca ilk yerel katkınızı göreceksiniz.

[İPUCU]
.Reflog'u Git'in kabuk (shell) geçmişi versiyonu olarak düşünebilirsiniz.
====
UNIX veya Linux geçmişiniz varsa, reflog'u Git'in kabuk geçmişinin versiyonu olarak düşünebilirsiniz. 
Bu, oradaki şeylerin sadece "sizle" ve "oturumunuzla" için açıkça ilgili olduğunu vurgular ve aynı makinede çalışan başka birinin bununla ilgisi olmadığını belirtir.
====

==== Soy Referansları

The other main way to specify a commit is via its ancestry.
If you place a `^` (caret) at the end of a reference, Git resolves it to mean the parent of that commit.
Suppose you look at the history of your project:

[source,console]
----
$ git log --pretty=format:'%h %s' --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit 'phedders/rdocs'
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
----

Then, you can see the previous commit by specifying `HEAD^`, which means ``the parent of HEAD'':

[source,console]
----
$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit 'phedders/rdocs'
----

[NOTE]
.Escaping the caret on Windows
====

On Windows in `cmd.exe`, `^` is a special character and needs to be treated differently.
You can either double it or put the commit reference in quotes:

[source,console]
----
$ git show HEAD^     # will NOT work on Windows
$ git show HEAD^^    # OK
$ git show "HEAD^"   # OK
----

====

You can also specify a number after the `^` to identify _which_ parent you want; for example, `d921970^2` means ``the second parent of d921970.''
This syntax is useful only for merge commits, which have more than one parent -- the _first_ parent of a merge commit is from the branch you were on when you merged (frequently `master`), while the _second_ parent of a merge commit is from the branch that was merged (say, `topic`):

[source,console]
----
$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon <schacon@gmail.com>
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly <paul+git@mjr.org>
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
----

The other main ancestry specification is the `~` (tilde).
This also refers to the first parent, so `HEAD~` and `HEAD^` are equivalent.
The difference becomes apparent when you specify a number.
`HEAD~2` means ``the first parent of the first parent,'' or ``the grandparent'' -- it traverses the first parents the number of times you specify.
For example, in the history listed earlier, `HEAD~3` would be

[source,console]
----
$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

This can also be written `HEAD~~~`, which again is the first parent of the first parent of the first parent:

[source,console]
----
$ git show HEAD~~~
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner <tom@mojombo.com>
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
----

You can also combine these syntaxes -- you can get the second parent of the previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and so on.

[[_commit_ranges]]
==== Commit Ranges

Now that you can specify individual commits, let's see how to specify ranges of commits.
This is particularly useful for managing your branches -- if you have a lot of branches, you can use range specifications to answer questions such as, ``What work is on this branch that I haven't yet merged into my main branch?''

===== Double Dot

The most common range specification is the double-dot syntax.
This basically asks Git to resolve a range of commits that are reachable from one commit but aren't reachable from another.
For example, say you have a commit history that looks like <<double_dot>>.

[[double_dot]]
.Example history for range selection.
image::images/double-dot.png[Example history for range selection.]

Say you want to see what is in your `experiment` branch that hasn't yet been merged into your `master` branch.
You can ask Git to show you a log of just those commits with `master..experiment` -- that means ``all commits reachable from experiment that aren't reachable from master.''
For the sake of brevity and clarity in these examples, the letters of the commit objects from the diagram are used in place of the actual log output in the order that they would display:

[source,console]
----
$ git log master..experiment
D
C
----

If, on the other hand, you want to see the opposite -- all commits in `master` that aren't in `experiment` -- you can reverse the branch names.
`experiment..master` shows you everything in `master` not reachable from `experiment`:

[source,console]
----
$ git log experiment..master
F
E
----

This is useful if you want to keep the `experiment` branch up to date and preview what you're about to merge.
Another frequent use of this syntax is to see what you're about to push to a remote:

[source,console]
----
$ git log origin/master..HEAD
----

This command shows you any commits in your current branch that aren't in the `master` branch on your `origin` remote.
If you run a `git push` and your current branch is tracking `origin/master`, the commits listed by `git log origin/master..HEAD` are the commits that will be transferred to the server.
You can also leave off one side of the syntax to have Git assume `HEAD`.
For example, you can get the same results as in the previous example by typing `git log origin/master..` -- Git substitutes `HEAD` if one side is missing.

===== Multiple Points

The double-dot syntax is useful as a shorthand, but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren't in the branch you're currently on.
Git allows you to do this by using either the `^` character or `--not` before any reference from which you don't want to see reachable commits.
Thus, the following three commands are equivalent:

[source,console]
----
$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
----

This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax.
For instance, if you want to see all commits that are reachable from `refA` or `refB` but not from `refC`, you can use either of:

[source,console]
----
$ git log refA refB ^refC
$ git log refA refB --not refC
----

This makes for a very powerful revision query system that should help you figure out what is in your branches.

[[_triple_dot]]
===== Triple Dot

The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by _either_ of two references but not by both of them.
Look back at the example commit history in <<double_dot>>.
If you want to see what is in `master` or `experiment` but not any common references, you can run:

[source,console]
----
$ git log master...experiment
F
E
D
C
----

Again, this gives you normal `log` output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering.

A common switch to use with the `log` command in this case is `--left-right`, which shows you which side of the range each commit is in.
This helps make the output more useful:

[source,console]
----
$ git log --left-right master...experiment
< F
< E
> D
> C
----

With these tools, you can much more easily let Git know what commit or commits you want to inspect.
