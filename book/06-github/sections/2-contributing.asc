=== Bir Projeye Katkıda Bulunmak

Artık bir Github hesabınız olduğuna göre, mevcut bir projeye katkıda bulunmakta yardımcı olabilecek bazı ayrıntıları gözden geçirelim.

==== Projeleri Çatallamak

(((forking)))
Bir erişim izniniz olmayan projeye katkıda bulunmak istiyorsanız, projeyi "çatallayabilirsiniz" (fork). 
Bir projeyi "çataladığınızda", GitHub projenin tamamen size ait bir kopyasını oluşturur; bu, sizin derleminizde (derlem: namespace) bulunur ve üzerine değişikliklerinizi itebilirsiniz.

[NOT]
====
"Projeyi çatallamak" (fork) ifadesi, geçmişte bir bağlamda oldukça olumsuz bir anlam taşımıştır: birinin açık kaynaklı bir projeyi farklı bir yöne taşıması, hatta bazen rekip bir proje oluşturarak katkıcıları bölmesi gibi. 
Ancak GitHub'da "çatallamak" terimi, sadece: üzerinde değişiklikler yaparak katkı sağlamak amacıyla, açık kaynak kodlu bir projeyi, kendi ad-alanınızda çoğaltmak anlamına gelir. 
====

Bu şekilde, kullanıcıları katkılayıcı olarak eklemek ve itme erişimi vermek gibi işlerle uğraşmak zorunda kalınmaz. 
İnsanlar bir projeyi çatallayabilir, kodlarını itebilir ve (bir sonraki adımda ele alacağımız üzere) değişikliklerini birleştirerek orijinal repoya katkıda bulunmak amacıyla bir birleştirme isteği (pull request) gönderebilirler. 
Böylece, proje sahibi ve katkıda bulunanlar arasında değişiklikler üzerine bir müzakere  başlar. 
Proje sahibi değişikliklerden memnun olduğu noktada bu değişiklikleri birleştirebilir.

Bir projeyi çatallamak için, projenin sayfasını ziyaret edin ve sayfanın sağ üst köşesindeki "Fork" (çatalla) düğmesine tıklayın.

."Fork" (Çatalla) düğmesi.
image::images/forkbutton.png["Fork" (Çatalla) düğmesi.]

Birkaç saniye sonra, kendi yazılabilir kodunuzun bir kopyasıyla yeni proje sayfanıza yönlendirileceksiniz.


[[ch06-github_flow]]
==== GitHub Akışı

(((GitHub, Flow)))
GitHub, birleştirme isteklerine odaklanan belirli bir iş birliği iş akışı etrafında tasarlanmıştır. 
Bu akış, ister tek bir ortak repoda sıkı işbirliği yapan bir ekiple, ister düzinelerce çatalı olan bir projeye katkıda bulunan ama birbirini tanımayan yabancılarla, isterse dünyanın dört bir yanında ofisleri bulunan küresel bir şirket için çalışın, sorunsuz bir şekilde çalışır. 
Bu, <<ch03-git-branching#ch03-git-branching>> bölümünde ele alınmış olan <<ch03-git-branching#_topic_branch>> iş akışına odaklanmıştır.

Genel olarak nasıl çalıştığı şöyle özetlenebilir:

1. fork: Projeyi çatallayın.
2. branch: `master` dalından konu bazlı (tematik) bir dal çıkarın.
3. commit: Projeyi geliştirmek için katkılar işleyin.
4. push: Bu dalı GitHub projenize itin.
5. pull Request: GitHub'ta bir birleştirme isteği açın.
6. Değişiklikleri proje sahibiyle tartışın ve katkı işlemeye devam edin.
7. merge: Proje sahibi değişiklikleri ana dala birleştirir veya birleştirme isteğini reddeder.
8. pull: Kendi çatalınızı güncellenmiş ana dala eşleyin.

Bu temel olarak <<ch05-distributed-git#_integration_manager>> bölümünde ele alınan Birleştirme Yöneticisi iş akışıdır, ancak değişiklikleri iletmek ve incelemek için e-posta yerine ekipler GitHub'ın ağ tabanlı araçlarını kullanır.

Örnek olarak, GitHub'da bulunan bir açık kaynak projesine, bu akışı kullanarak bir değişiklik önerisini birlikte inceleyelim.

===== Birleştirme İsteği Oluşturmak

Diyelim ki, Arduino programlanabilir mikrodenetleyicisinde çalıştırmak için kod arayan Tony https://github.com/schacon/blink[] adresinde harika bir program dosyası bulur.

.Katkıda bulunmak istediğimiz proje.
image::images/blink-01-start.png[TKatkıda bulunmak istediğimiz proje.]

Tek sorun, yanıp sönme hızının çok yüksek olması.
Her ışıltı arasında 1 saniye yerine 3 saniye beklemenin çok daha iyi olduğunu düşünüyoruz.
Bu yüzden programı iyileştirelim ve bir değişiklik önerisi olarak projeye geri gönderelim.

Öncelikle, kendi kopyamızını almak için yukarıda belirtildiği gibi 'Fork' düğmesine tıklıyoruz.
Kullanıcı adımız burada "tonychacon" olduğu için kendi kopyamızı `https://github.com/tonychacon/blink` adresinde bulabilir ve burada düzenleyebiliriz.
Yerel olarak kopyalayacak, bir tema dalı oluşturacak, kod değişikliği yapacak ve son olarak bu değişikliği GitHub'a geri iteceğiz.

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino (macOS) <3>
# If you're on a Linux system, do this instead:
# $ sed -i 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> Projemizin kendi çatalını yerel olarak kopyalayın.
<2> Açıklayıcı bir tema dalı oluşturun.
<3> Kodda değişiklik yapın.
<4> Değişikliğin iyi olduğundan emin olun.
<5> Değişikliği tema dalına katkı olarak işleyin.
<6> Yeni tema dalınzı GitHub çatalınıza geri itin.

Şimdi GitHub'daki çatalımıza geri dönersek; GitHub'ın yeni tema dalını ittiğinizi fark ettiğini, değişikliklerimizi kontrol etmek ve orijinal projeye bir Birleştirme İsteği açmak için büyük yeşil bir düğme sunduğunu görebiliriz.

Alternatif olarak, `<kullanıcı>/<proje>/dal` (örnekte: tonychacon/blink/tema_dalı) adresindeki "Branches" (dallar) sayfasına giderek dalınızı bulabilir ve oradan yeni bir birleştirme isteği açabilirsiniz.



.Birleştirme isteği düğmesi
image::images/blink-02-pr.png[Birleştirme isteği düğmesi]

(((GitHub, pull requests)))
Yeşil düğmeye tıklarsak, birleştirme isteğimize bir başlık ve açıklama vermemizi isteyen bir ekran görürüz.
Genellikle buna biraz çaba harcamak faydalı olur, çünkü iyi bir açıklama, orijinal projenin sahibinin ne yapmaya çalıştığınızı, önerdiğiniz değişikliklerin doğru olup olmadığını ve değişikliklerin kabul edilmesinin orijinal projeyi iyileştirip iyileştirmeyeceğini belirlemesine yardımcı olur.

Ayrıca, `master` dalından önde (ahead) olan tema dalımızdaki katkıların bir listesini (bu senaryoda sadece bir tane) ve bu dalın projenin sahibi tarafından birleştirilmesi durumunda yapılacak tüm değişikliklerin birleştirilmiş bir farkını görürüz.


."Birleştirme İsteği" oluşturma sayfası
image::images/blink-03-pull-request-open.png["Birleştirme İsteği" oluşturma]

Bu ekranda 'Create pull request' (birleştirme isteği oluştur) düğmesine tıkladığınızda, çatalınızı aldığınız proje sahibi bir değişiklik önerildiği konusunda bir bildirim alacak ve tüm bu bilgilere bağlantı veren bir sayfaya yönlendirilecek.

[NOT]
====
Birleştirme İstekleri genellikle katkı sağlayan kişi tamamlanmış bir değişikliği yapmaya hazır olduğunda, bu gibi açık projelerde yaygın olarak kullanılır; ancak iç projelerde geliştirme döngüsünün _başında_ da sıklıkla kullanılır.
Çünkü Birleştirme İsteği açıldıktan *sonra* bile tema dalına güncelleme yapabilirsiniz. 
Genellikle projenin sonunda değil, başında açılır; işi ekipçe, bir bağlam içinde ardışık yapabilmek için bir yol olarak kullanılır.
====

===== Birleştirme İsteği Tekrarı

Bu noktada, proje sahibi önerilen değişikliği inceleyebilir, birleştirebilir, reddedebilir veya üzerine yorum yapabilir. Diyelim ki fikri beğendi, ancak ışığın kapalı kalma süresinin, açık kalma süresinden biraz daha uzun sürmesini tercih etti.

Bu konuşma, GitHub üzerinde çevrimiçi olarak gerçekleşirken, <<ch05-distributed-git#ch05-distributed-git>> bölümünde sunulan iş akışlarında e-posta üzerinden gerçekleşir. 
Proje sahibi, birleştirilmiş farkı gözden geçirebilir ve herhangi bir satıra tıklayarak bir yorum bırakabilir.

.Birleştirme isteğindeki belirli bir kod satırına yorum yapmak
image::images/blink-04-pr-comment.png[Birleştirme isteği satır yorumu]

Yönetici bu yorumu yaptıktan sonra, isteği açan kişi (ve hatta repoyu izleyen herkes) bir bildirim alır.
Bunu özelleştirmeyi daha sonra ele alacağız, ancak e-posta bildirimlerini açmış olsaydı, Tony şöyle bir e-posta alırdı:

[[_email_notification]]
.E-posta bildirimi olarak gönderilen yorum
image::images/blink-04-email.png[E-posta bildirimi]

Ayrıca herkes bu birleştirme isteği üzerine herkese açık yorumlar da yapabilir.
<<_pr_discussion>> bölümünde, projenin sahibinin hem bir kod satırına yorum yapması, hem de tartışma bölümünde genel bir yorum bırakması örneğini görebilirsiniz.
Kod yorumlarının da konuşmaya dahil edildiğini görebilirsiniz.

[[_pr_discussion]]
.Birleştirme isteği tartışma sayfası
image::images/blink-05-general-comment.png[Birleştirme isteği tartışma sayfası]

Şimdi katkılayıcı, değişikliklerinin kabul edilmesi için yapması gerekenleri görebilir.
Neyse ki bu çok basittir.
E-posta üzerinden serinizi tekrar oluşturup, posta listesine yeniden göndermeniz gerekirken; GitHub'ta sadece konu dalına tekrar katkı işleyip iterseniz, birleştirme isteği otomatik olarak güncellenir.
<<_pr_final>> bölümünde, güncellenen bir birleştirme isteğindeki eski kod yorumunun, artık değiştirilmiş bir satıra yapıldığı için daraltıldığını görebilirsiniz.

Varolan bir birleştirme talebine yeni katkılar işlemek, bir bildirim tetiklemez; bu yüzden Tony düzeltmelerini ittikten sonra, proje sahibine istenen değişikliği yaptığını bildirmek için bir yorum bırakmaya karar verir.

[[_pr_final]]
.Birleştirme isteği kapanışı
image::images/blink-06-final.png[Birleştirme isteği kapanışı]

Bu birleştirme talebinin "Files Changed" (Değiştirilen Dosyalar) sekmesine tıklarsanız, "bileşke fark"ı alırsınız; yani, bu konu dalı birleştirildiğinde, ana dalınıza kaynaşacak olan tüm kod farkını.
`git diff` terimi, temelde bu birleştirme isteğinin dayandığı dal için `git diff master...<branch>` komut çıktısını site otomatik olarak gösterir.
Bu tür bir fark hakkında daha fazla bilgi için <<ch05-distributed-git#_what_is_introduced>> bölümüne bakın.

Diğer bir dikkat çekici nokta ise; GitHub'ın birleştirme isteğinin temiz bir şekilde birleştirilip birleştirilemeyeceğini kontrol etmesi ve birleştirmeyi sunucuda yapmak için bir düğme oluşturmasıdır. 
Bu düğme, repoya yazma erişiminiz varsa ve basit birleşme mümkünse görünür. 
Tıklarsanız, GitHub "ileri-sarma" (fast-forward) *olabilecek durumlarda* bile "ileri-sarmayan" (non-fast-forward) birleşmesi gerçekleştirir ve bir birleştirme katkısı oluşturur.

Tercih ederseniz, basitçe dalı çekip (pull), yerelde birleştirebilirsiniz (merge). 
Bu dalı `master` dala birleştirir ve GitHub'a iterseniz, birletşirme isteği otomatik olarak kapanır.

Bu, çoğu GitHub projesinin kullandığı temel iş akışıdır. 
Konu dalları oluşturulur, üzerlerinde birleştirme istekleri açılır, bir tartışma başlar, belki daha fazla çalışma yapılır ve sonunda istek ya kapatılır ya da birleştirilir.


[NOT]
.Çatal zorunlu değil
====
Önemli bir nokta da, aynı repodaki iki dal arasında da bir birleştirme isteği açabileceğinizdir. 
Bir özellik üzerinde birileriyle birlikte çalışıyorsanız ve her ikininin de projeye yazma erişimi varsa; bir konu dalını repoya itebilir; ardından üzerinde tartışma ve kod incelemesi sürecini başlatmak için, aynı projenin `master` dalına bir birleştirme talebi açabilirsiniz. 
Çatallamanız gerekmez.
====

==== Gelişmiş Birleştirme İstekleri

GitHub'daki bir projeye katkıda bulunmanın temellerini öğrendikten sonra, birleştirme istekleriyle ilgili birkaç ilginç ipucunu ve püf noktasını öğrenelim; böylece onları daha etkili bir şekilde kullanabilirsiniz.

===== Yama Olarak Birleştirme İsteği

It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions.
Most GitHub projects think about Pull Request branches as iterative conversations around a proposed change, culminating in a unified diff that is applied by merging.

This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions.
This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort.
When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.

For instance, if you go back and look again at <<_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request.
Instead they added new commits and pushed them to the existing branch.
This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made.
Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.

===== Keeping up with Upstream

If your Pull Request becomes out of date or otherwise doesn't merge cleanly, you will want to fix it so the maintainer can easily merge it.
GitHub will test this for you and let you know at the bottom of every Pull Request if the merge is trivial or not.

[[_pr_fail]]
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]

If you see something like <<_pr_fail>>, you'll want to fix your branch so that it turns green and the maintainer doesn't have to do extra work.

You have two main options in order to do this.
You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.

Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section.
What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.

If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.

For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request.
Let's go through those steps.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch of that repository into your topic branch
<4> Fix the conflict that occurred
<5> Push back up to the same topic branch

Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.

[[_pr_merge_fix]]
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]

One of the great things about Git is that you can do that continuously.
If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.

If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on.
If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<ch03-git-branching#_rebase_peril>>.
Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.

===== References

Your next question may be ``How do I reference the old Pull Request?''.
It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.

Let's start with how to cross-reference another Pull Request or an Issue.
All Pull Requests and Issues are assigned numbers and they are unique within the project.
For example, you can't have Pull Request #3 _and_ Issue #3.
If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description.
You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.

Let's look at an example.
Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one.
We also want to reference an issue in the fork of the repository and an issue in a completely different project.
We can fill out the description just like <<_pr_references>>.

[[_pr_references]]
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]

When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.

[[_pr_references_render]]
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]

Notice that the full GitHub URL we put in there was shortened to just the information needed.

Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline.
This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it.
The link will look something like <<_pr_closed>>.

[[_pr_closed]]
.Link back to the new Pull Request in the closed Pull Request timeline.
image::images/mentions-03-closed.png[PR closed]

In addition to issue numbers, you can also reference a specific commit by SHA-1.
You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit.
Again, you can reference commits in forks or other repositories in the same way you did with issues.

==== GitHub Flavored Markdown

Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub.
In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''.
Markdown is like writing in plain text but which is rendered richly.

See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.

[[_example_markdown]]
.An example of GitHub Flavored Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]

The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax.
These can all be really useful when creating useful Pull Request or Issue comments or descriptions.

===== Task Lists

The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List.
A task list is a list of checkboxes of things you want to get done.
Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.

You can create a task list like this:

[source,text]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_eg_task_lists>>

[[_eg_task_lists]]
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]

This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge.
The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.

What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out.
For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is.
This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch.
You can see an example of this in <<_task_list_progress>>.

[[_task_list_progress]]
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]

These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.

===== Code Snippets

You can also add code snippets to comments.
This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch.
This is also often used to add example code of what is not working or what this Pull Request could implement.

To add a snippet of code you have to ``fence'' it in backticks.

[source,text]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet.
In the case of the above example, it would end up rendering like <<_md_code>>.

[[_md_code]]
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]

===== Quoting

If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character.
In fact, this is so common and so useful that there is a keyboard shortcut for it.
If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.

The quotes look something like this:

[source,text]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

Once rendered, the comment will look like <<_md_quote>>.

[[_md_quote]]
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]

===== Emoji

Finally, you can also use emoji in your comments.
This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests.
There is even an emoji helper in GitHub.
If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.

[[_md_emoji_auto]]
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]

Emojis take the form of `:<name>:` anywhere in the comment.
For instance, you could write something like this:

[source,text]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

When rendered, it would look something like <<_md_emoji>>.

[[_md_emoji]]
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]

Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.


[NOTE]
====
There are actually quite a number of web services that make use of emoji characters these days.
A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

https://www.webfx.com/tools/emoji-cheat-sheet/
====

===== Images

This isn't technically GitHub Flavored Markdown, but it is incredibly useful.
In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.

[[_md_drag]]
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]

If you look at <<_md_drag>>, you can see a small ``Parsed as Markdown'' hint above the text area.
Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.

[[_fetch_and_push_on_different_repositories]]
==== Keep your GitHub public repository up-to-date

Once you've forked a GitHub repository, your repository (your "fork") exists independently from the original.
In particular, when the original repository has new commits, GitHub informs you by a message like:

[source,text]
----
This branch is 5 commits behind progit:master.
----

But your GitHub repository will never be automatically updated by GitHub; this is something that you must do yourself.
Fortunately, this is very easy to do.

One possibility to do this requires no configuration.
For example, if you forked from `https://github.com/progit/progit2.git`, you can keep your `master` branch up-to-date like this:

[source,console]
----
$ git checkout master <1>
$ git pull https://github.com/progit/progit2.git <2>
$ git push origin master <3>
----

<1> If you were on another branch, return to `master`.
<2> Fetch changes from `https://github.com/progit/progit2.git` and merge them into `master`.
<3> Push your `master` branch to `origin`.

This works, but it is a little tedious having to spell out the fetch URL every time.
You can automate this work with a bit of configuration:

[source,console]
----
$ git remote add progit https://github.com/progit/progit2.git <1>
$ git branch --set-upstream-to=progit/master master <2>
$ git config --local remote.pushDefault origin <3>
----

<1> Add the source repository and give it a name.
    Here, I have chosen to call it `progit`.
<2> Set your `master` branch to fetch from the `progit` remote.
<3> Define the default push repository to `origin`.

Once this is done, the workflow becomes much simpler:

[source,console]
----
$ git checkout master <1>
$ git pull <2>
$ git push <3>
----

<1> If you were on another branch, return to `master`.
<2> Fetch changes from `progit` and merge changes into `master`.
<3> Push your `master` branch to `origin`.

This approach can be useful, but it's not without downsides.
Git will happily do this work for you silently, but it won't warn you if you make a commit to `master`, pull from `progit`, then push to `origin` -- all of those operations are valid with this setup.
So you'll have to take care never to commit directly to `master`, since that branch effectively belongs to the upstream repository.
