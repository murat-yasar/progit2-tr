=== GitHub'ı otomatikleştirme

Şimdi GitHub'ın tüm önemli özelliklerini ve iş akışlarını ele aldık, ancak büyük bir grup veya projenin her zaman yapabileceği özelleştirmeler veya eklemek isteyebileceği harici hizmetler olacaktır.

Neyse ki, GitHub birçok yönden oldukça esnek. 
Bu bölümde, GitHub'ın kanca (hook) sistemi ve API'sini nasıl kullanacağımızı ve GitHub'ı istediğimiz gibi çalıştırmak için nasıl kullanabileceğimizi ele alacağız.

==== Kancalar ve Hizmetler (Hooks and Services)

GitHub repo yönetiminin "Hooks and Services" (Kancalar ve Hizmetler) bölümü, GitHub'ı harici sistemlerle etkileştirmenin en kolay yoludur.

===== Hizmetler (Services)

Öncelikle Hizmetlere bir göz atalım. 
Kancalar ve Hizmetler entegrasyonlarını, reponuzun - daha önce ortak eklemeyi ve projenizin varsayılan dalını değiştirdiğimiz yer olan- "Settings" (Ayarlar) bölümünde bulabilirsiniz. 
``Webhooks and Services`` (ağ Kancaları ve Hizmetler) sekmesi altında <<_services_hooks>> gibi bir şey göreceksiniz.

[[_services_hooks]]
.Hizmetler ve Kancalar yapılandırma bölümü.
image::images/scripting-01-services.png[Hizmetler ve kancalar]

Çoğu diğer ticari ve açık kaynak sistemlere entegrasyon sunan onlarca hizmet arasından dileğinizi seçebilirsiniz. 
Bunların çoğu, daimi entegrasyon hizmetleri, hata ve sorun izleyicileri, sohbet odası sistemleri ve belgeleme sistemleri içindir. 
Şimdi bunlar içerisinden, çok basit bir hizmet olan E-posta kanca hizmetini kurmayı göstereceğiz. 
Eğer ``Add Service`` (Hizmet Ekle) açılır menüsünden ``email``'i seçerseniz, karşınıza <<_service_config>> gibi bir yapılandırma ekranı çıkar.

[[_service_config]]
.E-posta hizmet yapılandırması.
image::images/scripting-02-email-service.png[E-posta hizmeti]

Burada ``Add service`` (Hizmet ekle) düğmesine basarsak, birisi repomuza her itme yaptığında belirttiğimiz e-posta adresine bir e-posta gelir. 
Hizmetler birçok farklı türde etkinlik dinleyebilir, ancak çoğu yalnızca itme etkinliklerini dinler ve ardından bu verilerle bir şeyler yapar.

Eğer GitHub ile entegre etmek istediğiniz bir sistem varsa, burada mevcut bir servis entegrasyonu olup olmadığını kontrol etmelisiniz. 
Örneğin, kod tabanınızda testleri çalıştırmak için Jenkins kullanıyorsanız, Jenkins'in yerleşik hizmet entegrasyonunu etkinleştirerek, biri reponuza itme yaptığında bir test çalıştırabilirsiniz.

===== Kancalar (Hooks)

Eğer daha belirli bir ihtiyacınız varsa veya bu listede bulunmayan bir servis veya siteyle entegre olmak istiyorsanız, daha genel kancaları kullanabilirsiniz.
GitHub repo kancaları oldukça basittir.
Bir URL belirtirsiniz ve GitHub istediğiniz herhangi bir etkinlikte o URL'ye bir HTTP yükü (payload) gönderir.

Bu genellikle, GitHub kancası yükünü dinlemesi için küçük bir ağ hizmeti kurulması ve veri alındığında onunla bir şeyler yapması şeklinde çalışır.

Bir kancayı etkinleştirmek için <<_services_hooks>>'daki ``Add webhook`` (ağ kancası ekle) düğmesine tıklarsınız.
Bu sizi <<_web_hook>> gibi bir sayfaya götürecektir.

[[_web_hook]]
.Ağ kancası yapılandırması.
image::images/scripting-03-webhook.png[Ağ kancası]

Bir ağ kancasını yapılandırmak çok basittir.
Çoğu durumda, sadece bir URL ve bir gizli anahtar girip, ardından ``Add webhook`` (Webhook ekle) düğmesine tıklarsınız.
GitHub'ın size bir yük göndermesini istediğiniz olaylar için birkaç seçenek vardır. 
Varsayılan olarak, yalnızca birisi herhangi bir repo dalına yeni bir kod ittiğinde bir yük alacağınız 'push' (itme) olayıdır.

Bir ağ kancasını yönetmek üzere ayarlayabileceğiniz bir ağ hizmetinin küçük bir örneğini görelim.
Oldukça kısa olduğundan ve ne yaptığımızı kolayca anlayabilmeniz gerektiğinden, Ruby ağ çerçevesi (framework) Sinatra'yı kullanacağız.

Diyelim ki, belirli bir kişinin, belirli bir dosyayı değiştirerek, belirli bir dala ittiğinde bir e-posta almak istiyoruz. 
Bunu aşağıdaki gibi bir kodla çok kolay bir şekilde yapabiliriz:

[source,ruby]
----
require 'sinatra'
require 'json'
require 'mail'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON

  # gather the data we're looking for
  pusher = push["pusher"]["name"]
  branch = push["ref"]

  # get a list of all the files touched
  files = push["commits"].map do |commit|
    commit['added'] + commit['modified'] + commit['removed']
  end
  files = files.flatten.uniq

  # check for our criteria
  if pusher == 'schacon' &&
     branch == 'ref/heads/special-branch' &&
     files.include?('special-file.txt')

    Mail.deliver do
      from     'tchacon@example.com'
      to       'tchacon@example.com'
      subject  'Scott Changed the File'
      body     "ALARM"
    end
  end
end
----

Burada GitHub'ın bize sunduğu JSON verisini alıp; kimin ittiğini, hangi dalı ittiğini ve hangi dosyaların değiştirildiğini kontrol ediyoruz.
Ardından, yukarıdaki kriterlere göre kontrol edip, eşleşiyorsa bir e-posta gönderiyoruz.

Böyle bir şey geliştirmek ve test etmek için, kancayı kurduğunuz ekranda güzel bir geliştirici konsolunuz bulunur.
GitHub'ın bu kanca için dağıtmaya çalıştığı son birkaç teslimatı görebilirsiniz.
Her kanca için: ne zaman teslim edildiğini, başarılı olup olmadığını, istek ve yanıtın gövdesini ve başlıklarını inceleyebilirsiniz.
Bu, kancalarınızı test etmeyi ve hataları ayıklamayı (debug) inanılmaz derecede kolaylaştırır.

[[_web_hook_debug]]
.Ağ kancası hata ayıklama bilgileri.
image::images/scripting-04-webhook-debug.png[Ağ kancası hata ayıklama]

Bunun diğer bir harika özelliği, hizmetinizi kolayca test etmek için yüklerden herhangi birini yeniden gönderebilmenizdir.

Web kancalarının nasıl yazılacağı ve dinleyebileceğiniz tüm farklı olay (event) türleri hakkında daha fazla bilgi için [GitHub Geliştirici belgelerine](https://developer.github.com/webhooks/) bakabilirsiniz.

==== GitHub API

(((GitHub, API)))
Hizmetler ve kancalar, repolarınızda gerçekleşen olaylar hakkında bildirim almanızı sağlar, ancak ya bu olaylar hakkında daha fazla bilgiye ihtiyacınız varsa!
Örneğin, projeye çalışma arkadaşı veya konulara etiket eklemek gibi bir şeyi otomatikleştirmeniz gerekiyorsa ne yapacaksınız?

İşte GitHub API'sinin devreye girdiği yer burasıdır.
GitHub, hemen hemen ağ sayfasındaki neredeyse her şeyi otomatikleştirebileceğiniz birçok API uç noktasına sahiptir.
Bu bölümde, API'ye kimlik doğrulama yapmayı, API'ye bağlanmayı, bir konuya yorum yapmayı ve bir birleştirme isteğinin durumunu değiştirmeyi öğreneceğiz.

==== Temel Kullanım

Yapabileceğiniz en temel şey, bir uç noktada kimlik doğrulaması gerektirmeyen basit bir GET isteğidir.
Bu, bir kullanıcı veya açık kaynaklı bir projedeki salt-okunur bilgiler olabilir.
Örneğin, ``schacon`` adlı bir kullanıcı hakkında daha fazla bilgi edinmek istiyorsak, şöyle bir şey çalıştırabiliriz:

[source,javascript]
----
$ curl https://api.github.com/users/schacon
{
  "login": "schacon",
  "id": 70,
  "avatar_url": "https://avatars.githubusercontent.com/u/70",
# …
  "name": "Scott Chacon",
  "company": "GitHub",
  "following": 19,
  "created_at": "2008-01-27T17:19:28Z",
  "updated_at": "2014-06-10T02:37:23Z"
}
----

GitHub üzerinde görebileceğiniz - herkese açık olarak yayınlanan - neredeyse her şey (topluluklar, projeler, konular, katkılar, vs) hakkında bilgi alabileceğiniz, buna benzer birçok uç nokta bulunmaktadır.
API'yi kullanarak keyfinize göre bir Markdown oluşturabilir veya bir `.gitignore` şablonu bulabilirsiniz.

[source,javascript]
----
$ curl https://api.github.com/gitignore/templates/Java
{
  "name": "Java",
  "source": "*.class

# Mobile Tools for Java (J2ME)
.mtj.tmp/

# Package Files #
*.jar
*.war
*.ear

# virtual machine crash logs, see https://www.java.com/en/download/help/error_hotspot.xml
hs_err_pid*
"
}
----


==== Bir Konuda Yorum Yapmak

However, if you want to do an action on the website such as comment on an Issue or Pull Request or if you want to view or interact with private content, you'll need to authenticate.

There are several ways to authenticate.
You can use basic authentication with just your username and password, but generally it's a better idea to use a personal access token.
You can generate this from the ``Applications'' tab of your settings page.

[[_access_token]]
.Generate your access token from the ``Applications'' tab of your settings page.
image::images/scripting-05-access-token.png[Access Token]

It will ask you which scopes you want for this token and a description.
Make sure to use a good description so you feel comfortable removing the token when your script or application is no longer used.

GitHub will only show you the token once, so be sure to copy it.
You can now use this to authenticate in your script instead of using a username and password.
This is nice because you can limit the scope of what you want to do and the token is revocable.

This also has the added advantage of increasing your rate limit.
Without authenticating, you will be limited to 60 requests per hour.
If you authenticate you can make up to 5,000 requests per hour.

So let's use it to make a comment on one of our issues.
Let's say we want to leave a comment on a specific issue, Issue #6.
To do so we have to do an HTTP POST request to `repos/<user>/<repo>/issues/<num>/comments` with the token we just generated as an Authorization header.

[source,javascript]
----
$ curl -H "Content-Type: application/json" \
       -H "Authorization: token TOKEN" \
       --data '{"body":"A new comment, :+1:"}' \
       https://api.github.com/repos/schacon/blink/issues/6/comments
{
  "id": 58322100,
  "html_url": "https://github.com/schacon/blink/issues/6#issuecomment-58322100",
  ...
  "user": {
    "login": "tonychacon",
    "id": 7874698,
    "avatar_url": "https://avatars.githubusercontent.com/u/7874698?v=2",
    "type": "User",
  },
  "created_at": "2014-10-08T07:48:19Z",
  "updated_at": "2014-10-08T07:48:19Z",
  "body": "A new comment, :+1:"
}
----

Now if you go to that issue, you can see the comment that we just successfully posted as in <<_api_comment>>.

[[_api_comment]]
.A comment posted from the GitHub API.
image::images/scripting-06-comment.png[API Comment]

You can use the API to do just about anything you can do on the website -- creating and setting milestones, assigning people to Issues and Pull Requests, creating and changing labels, accessing commit data, creating new commits and branches, opening, closing or merging Pull Requests, creating and editing teams, commenting on lines of code in a Pull Request, searching the site and on and on.

==== Changing the Status of a Pull Request

There is one final example we'll look at since it's really useful if you're working with Pull Requests.
Each commit can have one or more statuses associated with it and there is an API to add and query that status.

Most of the Continuous Integration and testing services make use of this API to react to pushes by testing the code that was pushed, and then report back if that commit has passed all the tests.
You could also use this to check if the commit message is properly formatted, if the submitter followed all your contribution guidelines, if the commit was validly signed -- any number of things.

Let's say you set up a webhook on your repository that hits a small web service that checks for a `Signed-off-by` string in the commit message.

[source,ruby]
----
require 'httparty'
require 'sinatra'
require 'json'

post '/payload' do
  push = JSON.parse(request.body.read) # parse the JSON
  repo_name = push['repository']['full_name']

  # look through each commit message
  push["commits"].each do |commit|

    # look for a Signed-off-by string
    if /Signed-off-by/.match commit['message']
      state = 'success'
      description = 'Successfully signed off!'
    else
      state = 'failure'
      description = 'No signoff found.'
    end

    # post status to GitHub
    sha = commit["id"]
    status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"

    status = {
      "state"       => state,
      "description" => description,
      "target_url"  => "http://example.com/how-to-signoff",
      "context"     => "validate/signoff"
    }
    HTTParty.post(status_url,
      :body => status.to_json,
      :headers => {
        'Content-Type'  => 'application/json',
        'User-Agent'    => 'tonychacon/signoff',
        'Authorization' => "token #{ENV['TOKEN']}" }
    )
  end
end
----

Hopefully this is fairly simple to follow.
In this web hook handler we look through each commit that was just pushed, we look for the string 'Signed-off-by' in the commit message and finally we POST via HTTP to the `/repos/<user>/<repo>/statuses/<commit_sha>` API endpoint with the status.

In this case you can send a state ('success', 'failure', 'error'), a description of what happened, a target URL the user can go to for more information and a ``context'' in case there are multiple statuses for a single commit.
For example, a testing service may provide a status and a validation service like this may also provide a status -- the ``context'' field is how they're differentiated.

If someone opens a new Pull Request on GitHub and this hook is set up, you may see something like <<_commit_status>>.

[[_commit_status]]
.Commit status via the API.
image::images/scripting-07-status.png[Commit status]

You can now see a little green check mark next to the commit that has a ``Signed-off-by'' string in the message and a red cross through the one where the author forgot to sign off.
You can also see that the Pull Request takes the status of the last commit on the branch and warns you if it is a failure.
This is really useful if you're using this API for test results so you don't accidentally merge something where the last commit is failing tests.

==== Octokit

Though we've been doing nearly everything through `curl` and simple HTTP requests in these examples, several open-source libraries exist that make this API available in a more idiomatic way.
At the time of this writing, the supported languages include Go, Objective-C, Ruby, and .NET.
Check out https://github.com/octokit[] for more information on these, as they handle much of the HTTP for you.

Hopefully these tools can help you customize and modify GitHub to work better for your specific workflows.
For complete documentation on the entire API as well as guides for common tasks, check out https://developer.github.com[].
