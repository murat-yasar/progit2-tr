[[_rebasing]]
=== Temelleme (rebase)

(((rebasing)))
Git'te, bir dalın değişikliklerini diğerine birleştirmenin iki ana yolu vardır: `merge` (birleştirme) ve `rebase` (temelleme). Bu bölümde, temellemenin ne olduğunu, nasıl yapıldığını, neden oldukça etkili bir araç olduğunu ve hangi durumlarda kullanmak istemeyeceğinizi öğreneceksiniz.

==== Basitçe Temelleme (rebase)

Eğer önceki örneğe, <<_basic_merging>> başlıklı bölüme geri dönerseniz, işinizi dallandırdığınızı ve iki farklı dalda katkı işlediğinizi görebilirsiniz.

.Basit bir ayrışma geçmişi
image::images/basic-rebase-1.png[Basit bir ayrışma geçmişi.]

Dalları birleştirmenin en kolay yolu, zaten ele aldığımız gibi `merge` komutudur. 
Bu komut, iki dalın (`C3` ve `C4`) ve bunların en son ortak öncelinin (`C2`) son pozlarını üçyönlü birleştirerek, yeni bir poz (ve katkı) oluşturur.

[[rebasing-merging-example]]
.Ayrık çalışma geçmişini birleştirmek
image::images/basic-rebase-2.png[Ayrık çalışma geçmişini birleştirmek.]

Ancak, başka bir yol daha vardır: `C4` ile tanıtılan değişikliğin yamasını alabilir ve bunu `C3`'ün üzerine yeniden uygulayabilirsiniz.
Git'te buna _temel alma_ veya _temelleme_ (rebasing) denir.
`rebase` komutu ile bir dalda işlenmiş tüm değişiklikleri alabilir ve bunları farklı bir dala aktararak bir temel olarak kullanabilirsiniz.(((git commands, rebase)))

Bu örnekte, `experiment` dalına geçer ve ardından onu şu şekilde `master` dalına aktarabilirsiniz:

[source,console]
----
$ git checkout experiment
$ git rebase master
First, rewinding head to replay your work on top of it...
Applying: added staged command
----

Bu işlem, iki dalın (üzerinde bulunduğunuz dal ve temel aldığınız dal) ortak önceline gitmesiyle başlar. 
Ardından, üzerinde bulunduğunuz dalın her katkısının getirdiği farkı alır ve bu farkları geçici dosyalara kaydeder. 
Mevcut dalı, üzerine temelleme yaptığınız dalın katkıları ile aynı katkıya sıfırlar ve son olarak her değişikliği sırayla uygular.

.`C4`teki değişikliği `C3` üzerine temelleme
image::images/basic-rebase-3.png[`C4`teki değişikliği `C3` üzerine temelleme.]

Bu noktada, `master` dalına geri dönebilir ve bir ileri-sarma birleştirmesi (fast-forward merge) yapabilirsiniz.

[source,console]
----
$ git checkout master
$ git merge experiment
----

.Master dalına ileri-sarma
image::images/basic-rebase-4.png[Master dalına ileri-sarma.]

Şu anda, `C4'` tarafından işaret edilen poz, <<rebasing-merging-example,the merge example>> örneğinde `C5` tarafından işaret edilen poz ile tam olarak aynıdır.
Birleştirme çıktısında fark yoktur, ancak temelleme daha temiz bir geçmiş sunar.
Eğer `git log` komutuyla temellenmiş bir dalın günlüğünü incelerseniz, doğrusal bir geçmiş görürsünüz. 
Başlangıçta eşzamanlı gerçekleşmiş olsa bile, tüm işin sırayla gerçekleştiği izlenimini verir.

Çoğu zaman bunu, katkılarınızın temiz bir şekilde bir uzak dala uygulanmasını sağlamak için yaparsınız, belki de bir süre üzerinde çalıştığınız ancak sürdürmediğiniz bir projede.
Bu durumda, işinizi bir dalda yapar ve yamalarınızı ana projeye göndermeye hazır olduğunuzda işinizi `origin/master` üzerine temellersiniz.
Bu şekilde, bakım yapan kişinin herhangi bir birleştirme çalışması yapmasına gerek kalmaz - sadece bir ileri-sarma veya temiz bir uygulama yapması yeterlidir.

Unutmayın ki, bu işlem sonunda elde ettiğiniz poz, ister bir temelleme işlemi için alınmış son temelleme katkısı, isterse birleştirme işlemi sonrası elde ettiğiniz son birleştirme katkısı olsun, aynı pozdur - farklı olan sadece tarihtir.
"Temelleme" (rebase) değişiklikleri tanımlandıkları sırayla bir iş çizgisinden başka bir iş çizgisine aktarırken, "birleştirme" (merge) uç noktaları alır ve bunları birleştirir.

==== Daha Detaylıca Temelleme

Temelleme işlemi için hedef aldığınız dal dışında bir dala da temellemenizi uygulayabilirsiniz.
Mesela <<rbdiag_e>> şeklindeki bir tarihçeyi ele alalım:
Projeye sunucu tarafı işlevselliği eklemek için `server` adında tematik bir dal oluşturdunuz ve bir katkı işlediniz. 
Ardından, istemci tarafındaki değişiklikleri yapmak için bu daldan ayrılıp `client` dalında birkaç katkı işlediniz. 
Son olarak, sunucu dalına geri dönüp birkaç katkı daha işlediniz.

[[rbdiag_e]]
.Bir tematik daldan ayrılan başka bir tematik dalın geçmişi.
image::images/interesting-rebase-1.png[Bir tematik daldan ayrılan başka bir tematik dalın geçmişi.]

Diyelim ki, bir sürüm için kullanıcı tarafındaki değişiklikleri ana dalınıza birleştirmeye karar verdiniz, ancak sunucu tarafındaki değişiklikleri daha fazla test edilene kadar bekletmek istiyorsunuz. 
Bu durumda, sunucu tarafında olmayıp (`C8` and `C9`) kullanıcı tarafında olan değişiklikleri alabilir ve onları `git rebase` komutunun `--onto` seçeneğini kullanarak `master` dalınıza temelleyebilirsiniz:

[source,console]
----
$ git rebase --onto master server client
----

Bu temel olarak şunu ifade eder: " `client` dalını al, bu dalın `server` dalından ayrıldığından bu yana yapılan yamaları belirle ve bu yamaları `client` dalında, sanki doğrudan `master` dalından temellenmiş gibi temelle."
Biraz karmaşık gibi görünebilir, ancak sonuç oldukça etkileyicidir.

.Tematik bir daldan yeni bir tematik dal temelleme
image::images/interesting-rebase-2.png[Tematik bir daldan yeni bir tematik dal temelleme.]

Artık `master` dalınızı ileri sarabilirsiniz (bkz. <<rbdiag_g>>):

[source,console]
----
$ git checkout master
$ git merge client
----

[[rbdiag_g]]
.`master` dalını `client` dalındaki değişiklikleri içerecek şekilde ileri sarmak.
image::images/interesting-rebase-3.png[`master` dalını `client` dalındaki değişiklikleri içerecek şekilde ileri sarmak.]

Diyelim ki sunucu dalını da eklemeye karar verdiniz.
`git rebase <temel-dalı> <tema-dalı>` komutunu çalıştırarak, öncesinde dalınızı değiştirmeden, sunucu dalını `master` dalına tekrar temelleyebilirsiniz. 
Bu komut, ilgili tema dalına (burada `server`) geçiş yapar ve onu temel dal üzerine (burada `master`) temeller.

[source,console]
----
$ git rebase master server
----

Bu, <<rbdiag_h>> diyagramında gösterildiği gibi `server` çalışmanızı `master` çalışmanızın üzerine temeller.

[[rbdiag_h]]
.`server` dalını `master` dalının üzerine temelleme.
image::images/interesting-rebase-4.png[`server` dalını `master` dalının üzerine temelleme.]

Ardından, temel dalınıza (`master`) ileri sarabilirsiniz:

[source,console]
----
$ git checkout master
$ git merge server
----

Tüm çalışmalar birleştirildiği için artık `client` ve `server` dallarını silebilirsiniz, çünkü bu sürecin tüm geçmişi zaten <<rbdiag_i>> şeklinde görünecektir:

[source,console]
----
$ git branch -d client
$ git branch -d server
----

[[rbdiag_i]]
.Final commit history
image::images/interesting-rebase-5.png[Final commit history.]

[[_rebase_peril]]
==== The Perils of Rebasing

(((rebasing, perils of)))
Ahh, but the bliss of rebasing isn't without its drawbacks, which can be summed up in a single line:

*Do not rebase commits that exist outside your repository and people may have based work on them.*

If you follow that guideline, you'll be fine.
If you don't, people will hate you, and you'll be scorned by friends and family.

When you rebase stuff, you're abandoning existing commits and creating new ones that are similar but different.
If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with `git rebase` and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.

Let's look at an example of how rebasing work that you've made public can cause problems.
Suppose you clone from a central server and then do some work off that.
Your commit history looks like this:

.Clone a repository, and base some work on it
image::images/perils-of-rebasing-1.png["Clone a repository, and base some work on it."]

Now, someone else does more work that includes a merge, and pushes that work to the central server.
You fetch it and merge the new remote branch into your work, making your history look something like this:

.Fetch more commits, and merge them into your work
image::images/perils-of-rebasing-2.png["Fetch more commits, and merge them into your work."]

Next, the person who pushed the merged work decides to go back and rebase their work instead; they do a `git push --force` to overwrite the history on the server.
You then fetch from that server, bringing down the new commits.

[[_pre_merge_rebase_work]]
.Someone pushes rebased commits, abandoning commits you've based your work on
image::images/perils-of-rebasing-3.png["Someone pushes rebased commits, abandoning commits you've based your work on."]

Now you're both in a pickle.
If you do a `git pull`, you'll create a merge commit which includes both lines of history, and your repository will look like this:

[[_merge_rebase_work]]
.You merge in the same work again into a new merge commit
image::images/perils-of-rebasing-4.png[You merge in the same work again into a new merge commit.]

If you run a `git log` when your history looks like this, you'll see two commits that have the same author, date, and message, which will be confusing.
Furthermore, if you push this history back up to the server, you'll reintroduce all those rebased commits to the central server, which can further confuse people.
It's pretty safe to assume that the other developer doesn't want `C4` and `C6` to be in the history; that's why they rebased in the first place.

[[_rebase_rebase]]
==== Rebase When You Rebase

If you *do* find yourself in a situation like this, Git has some further magic that might help you out.
If someone on your team force pushes changes that overwrite work that you've based work on, your challenge is to figure out what is yours and what they've rewritten.

It turns out that in addition to the commit SHA-1 checksum, Git also calculates a checksum that is based just on the patch introduced with the commit.
This is called a ``patch-id''.

If you pull down work that was rewritten and rebase it on top of the new commits from your partner, Git can often successfully figure out what is uniquely yours and apply them back on top of the new branch.

For instance, in the previous scenario, if instead of doing a merge when we're at <<_pre_merge_rebase_work>> we run `git rebase teamone/master`, Git will:

* Determine what work is unique to our branch (C2, C3, C4, C6, C7)
* Determine which are not merge commits (C2, C3, C4)
* Determine which have not been rewritten into the target branch (just C2 and C3, since C4 is the same patch as C4')
* Apply those commits to the top of `teamone/master`

So instead of the result we see in <<_merge_rebase_work>>, we would end up with something more like <<_rebase_rebase_work>>.

[[_rebase_rebase_work]]
.Rebase on top of force-pushed rebase work.
image::images/perils-of-rebasing-5.png[Rebase on top of force-pushed rebase work.]

This only works if C4 and C4' that your partner made are almost exactly the same patch.
Otherwise the rebase won't be able to tell that it's a duplicate and will add another C4-like patch (which will probably fail to apply cleanly, since the changes would already be at least somewhat there).

You can also simplify this by running a `git pull --rebase` instead of a normal `git pull`.
Or you could do it manually with a `git fetch` followed by a `git rebase teamone/master` in this case.

If you are using `git pull` and want to make `--rebase` the default, you can set the `pull.rebase` config value with something like `git config --global pull.rebase true`.

If you only ever rebase commits that have never left your own computer, you'll be just fine.
If you rebase commits that have been pushed, but that no one else has based commits from, you'll also be fine.
If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble, and the scorn of your teammates.

If you or a partner does find it necessary at some point, make sure everyone knows to run `git pull --rebase` to try to make the pain after it happens a little bit simpler.

==== Rebase vs. Merge

(((rebasing, vs. merging)))(((merging, vs. rebasing)))
Now that you've seen rebasing and merging in action, you may be wondering which one is better.
Before we can answer this, let's step back a bit and talk about what history means.

One point of view on this is that your repository's commit history is a *record of what actually happened.*
It's a historical document, valuable in its own right, and shouldn't be tampered with.
From this angle, changing the commit history is almost blasphemous; you're _lying_ about what actually transpired.
So what if there was a messy series of merge commits?
That's how it happened, and the repository should preserve that for posterity.

The opposing point of view is that the commit history is the *story of how your project was made.*
You wouldn't publish the first draft of a book, and the manual for how to maintain your software deserves careful editing.
This is the camp that uses tools like rebase and filter-branch to tell the story in the way that's best for future readers.

Now, to the question of whether merging or rebasing is better: hopefully you'll see that it's not that simple.
Git is a powerful tool, and allows you to do many things to and with your history, but every team and every project is different.
Now that you know how both of these things work, it's up to you to decide which one is best for your particular situation.

In general the way to get the best of both worlds is to rebase local changes you've made but haven't shared yet before you push them in order to clean up your story, but never rebase anything you've pushed somewhere.
