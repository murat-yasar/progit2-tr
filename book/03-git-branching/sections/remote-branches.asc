[[_remote_branches]]
=== Uzak Dallar

(((branches, remote)))(((references, remote)))
Uzak işaretçiler, uzak repolarınızdaki dalları, etiketleri ve benzerlerini içeren işaretçilerdir.
`git ls-remote [remote]` veya `git remote show [remote]` komutları ile uzak işaretçilerin tam listesini alabilir ve daha fazla bilgi edinebilirsiniz.
Daha yaygın bir yöntem ise uzak izleme dallarından yararlanmaktır.

Uzak izleme dalları, uzak dalların durumunu gösteren işaretçilerdir.
Bunlar, hareket ettiremeyeceğiniz yerel işaretçilerdir. 
Git, herhangi bir ağ iletişimi yaptığınızda bunları sizin için taşır ve bu sayede uzak repo durumunu doğru bir şekilde temsil ettiklerinden emin olur.
Onları, son bağlandığınızda uzak repolarınızdaki dalların nerede olduğunu hatırlatan birer yer işareti gibi düşünebilirsiniz.

Uzaktan izlenen (remote-tracking) dal isimleri `<remote>/<branch>` şeklindedir.
Örneğin, `origin` uzak repo ile en son iletişim kurduğunuzda `master` dalının ne durumda olduğunu görmek istiyorsanız, `origin/master` dalına bir göz atarsınız.
Meslektaşlarınızla bir iş paketi üzerinde çalışıyorsanız ve onlar yeni bir katkı işleyerek `iss53` dalını yukarı itmişse; kendi yerel `iss53` dalınız olabilir ancak sunucuda yer alan dal, uzak izleme dalı olan `origin/iss53` tarafından temsil edilir.

Bu biraz karışık olabileceği için bir örnekle inceleyelim.
Diyelim ki yerel ağınızdaki `git.ourcompany.com` sayfası üzerinde bir Git sunucunuz var. 
Eğer bu sunucudan kopyalama işlemi yapıyorsanız, `git clone` komutu otomatik olarak ona `origin` adını verir, tüm verilerini indirir, `master` dalının bulunduğu yeri gösteren bir işaretçi oluşturur ve bu işaretçiyi yerelde `origin/master` olarak adlandırır.
Git ayrıca üzerinde çalışabileceğiniz bir başlangıç noktası olabilmesi için sizin kendi yerel `master` dalınızı da oluşturur. 
Bu dal da `origin` sunucusunun `master` dalıyla aynı yerden başlar.

[NOT]
.``origin`` özel değildir
====
"Master" dal adının Git'te özel bir anlamı olmadığı gibi, "origin" adı da özel bir anlama sahip değildir.
"Master", `git init` komutunu çalıştırdığınızda başlangıç dalı için varsayılan isim olduğu için yaygın olarak kullanılır. 
Benzer şekilde, "origin" de `git clone` komutunu çalıştırdığınızda varsayılan uzak sunucu adıdır.
Eğer `git clone -o booyah` şeklinde bir komut çalıştırırsanız, o zaman varsayılan uzak dalınız `booyah/master` olacaktır.(((origin)))
====

.Kopyalamamadan sonra sunucu ve yerel repolar
image::images/remote-branches-1.png[Kopyalamamadan sonra sunucu ve yerel repolar.]

Eğer yerel `master` dalında çalışıyorsanız ve aynı zamanda başka birisi `git.ourcompany.com` üzerine bir değişiklik yüklüyorsa (push), kendi `master` dalını güncelledikce, geçmişleriniz farklı yönlere ilerler.
Ayrıca, kendi origin sunucunuzla iletişimde olmadığınız sürece, `origin/master` işaretçisi yer değiştirmez.


.Yerel ve uzak çalışma farklılaşabilir
image::images/remote-branches-2.png[Yerel ve uzak çalışma farklılaşabilir.]

Belirli bir uzak repo ile çalışmanızı eşzamanlamak (synchronize) için `git fetch <remote>` komutunu çalıştırırsınız (bizim durumumuzda, `git fetch origin`).
Bu komut, `origin`in hangi sunucuda olduğuna (bu durumda, `git.ourcompany.com`) bakar, henüz alınmayan verileri yakalar (fetch), yerel veritabanınızı günceller ve `origin/master` işaretçisini yeni ve daha güncel konumuna taşır.

.`git fetch` uzak takip dallarınızı günceller
image::images/remote-branches-3.png[`git fetch` zak takip dallarınızı günceller.]

Çoklu uzak sunuculara sahip olmanın ve bu uzak projelerin uzak dallarının nasıl göründüğünü anlamak için, şu hayali senaryoya başvuralım: Diyelim ki sadece çevik takımlarınızdan birisi tarafından geliştirme amaçlı kullanılan başka bir iç Git sunucunuz var ve bu sunucu `git.team1.ourcompany.com` adresinde bulunmaktadır.
Bunu şu an üzerinde çalıştığınız projeye <<ch02-git-basics#ch02-git-basics>> bölümünde ele aldığımız gibi `git remote add` komutu ile yeni bir uzak işaretçi olarak ekleyebilirsiniz.
Bu uzak sunucuyu kısaca `teamone` olarak adlandırın.

.Başka bir sunucuyu uzak (remote) olarak eklemek
image::images/remote-branches-4.png[Başka bir sunucuyu uzak olarak eklemek.]

Şimdi, `git fetch teamone` komutunu çalıştırarak, henüz sahip olmadığınız tüm verileri uzak `teamone` sunucusundan çekebilirsiniz.
Bu sunucu şu anda `origin` sunucunuzun sahip olduğu verilerin bir alt kümesine sahip olduğu için, Git hiç veri çekmez ancak `teamone`ın kendi `master` dalındaki katkıya işaret eden `teamone/master` adında bir uzak takip dalı ayarlar.

.teamone/master` için uzak takip dalı
image::images/remote-branches-5.png[`teamone/master` için uzak takip dalı.]

[[_pushing_branches]]
==== Yükleme (pushing)

(((pushing)))
Bir dalı dünyayla paylaşmak istediğinizde, yazma erişimine sahip olduğunuz bir uzak sunucuya yüklemeniz (push) gerekiyor.
Yerel dallarınız, yazma işlemi yapabileceğiniz uzak sunuculara otomatik olarak eşzamanlandırılmaz; paylaşmak istediğiniz dalları açıkça yüklemeniz gerekir.
Bu şekilde, paylaşmak istemediğiniz işler için özel (private) dallar kullanabilir ve yalnızca işbirliği yapmak istediğiniz tematik dalları yükleyebilirsiniz.

Eğer diğerleriyle birlikte çalışmak istediğiniz `serverfix` adında bir dalınız varsa, onu ilk dalınızı yüklediğiniz şekilde yükleyebilirsiniz.

`git push <remote> <branch>` komutunu çalıştırın:(((git commands, push)))

[source,console]
----
$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -> serverfix
----

Bu biraz kısayol gibidir. 
Git otomatik olarak `serverfix` dal ismini `refs/heads/serverfix:refs/heads/serverfix` şeklinde genişletir: Bu 'Lütfen benim yerel `serverfix` dalımı al ve onu uzaktaki `serverfix` dalını güncellemek için it' anlamına gelir.
`refs/heads/` kısmını daha sonra <<ch10-git-internals#ch10-git-internals>> bölümünde detaylı bir şekilde ele alacağız, ancak bunu genellikle belirtmenize gerek yoktur.
Aynı işlemi gerçekleştiren bir diğer yöntem de `git push origin serverfix:serverfix` şeklinde kullanmaktır. 
Bu da 'Lütfen benim `serverfix` dalımı al ve onu uzaktaki `serverfix` dalı yap' anlamına gelir. 
Bu formatı kullanarak, yerel bir dalı farklı bir isimdeki uzak bir dala itebilirsiniz. 
Eğer uzakta `serverfix` olarak adlandırılmış bir dal istemiyorsanız, bunun yerine yerel `serverfix` dalınızı uzaktaki projedeki `awesomebranch` dalına itmek için `git push origin serverfix:awesomebranch` komutunu çalıştırabilirsiniz.

[NOT]
.Her defasında şifrenizi yazmayın
====
Eğer bir HTTPS URL'si kullanarak itme (push) işlemi yapıyorsanız, Git sunucusu sizden kimlik doğrulaması için kullanıcı adı ve şifrenizi isteyecektir. 
Varsayılan olarak, Git bu bilgileri size terminal üzerinden sorması için bir istekte bulunur. 
Böylece sunucu itmeye izin verip vermediğinizi kontrol edebilir.

Her itme (push) işlemi yaparken bunu her seferinde yazmak istemiyorsanız, bir 'credential cache' (kimlik bilgisi önbelleği) kurabilirsiniz. En basit olanı, bunu birkaç dakika boyunca bellekte tutmaktır ve bunu kolayca `git config --global credential.helper cache` komutunu çalıştırarak yapabilirsiniz.

Çeşitli kimlik bilgisi önbelleği seçenekleri hakkında daha fazla bilgi için <<ch07-git-tools#_credential_caching>> bölümüne bakabilirsiniz.

====

Bir sonraki seferde bir meslektaşınız sunucudan veri çektiğinde, sunucunun `serverfix` dalının versiyonuna dair referansı, uzak dal `origin/serverfix` altında olacaktır:

[source,console]
----
$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -> origin/serverfix
----

Yeni uzak takip dallarını getiren bir çekme işlemi yaptığınızda, bunların  düzenlenebilir yerel kopyalarına otomatik olarak sahip olmazsınız.
Yani bu durumda, yeni bir `serverfix` dalınız olmaz -- sadece üzerinde değişiklik yapamayacağınız bir `origin/serverfix` işaretçiniz olur.

Bu çalışmayı mevcut çalışma dalınıza birleştirmek için `git merge origin/serverfix` komutunu çalıştırabilirsiniz.
Eğer üzerinde çalışabileceğiniz kendi `serverfix` dalınızı istiyorsanız, bunu uzak takip dalınızın üzerine kurabilirsiniz:

[source,console]
----
$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

Böylelikle, `origin/serverfix`'in başladığı yerden devam eden ve üzerinde çalışabileceğiniz bir yerel dal elde etmiş olursunuz.

[[_tracking_branches]]
==== Tracking Branches

(((branches, tracking)))(((branches, upstream)))
Checking out a local branch from a remote-tracking branch automatically creates what is called a ``tracking branch'' (and the branch it tracks is called an ``upstream branch'').
Tracking branches are local branches that have a direct relationship to a remote branch.
If you're on a tracking branch and type `git pull`, Git automatically knows which server to fetch from and which branch to merge in.

When you clone a repository, it generally automatically creates a `master` branch that tracks `origin/master`.
However, you can set up other tracking branches if you wish -- ones that track branches on other remotes, or don't track the `master` branch.
The simple case is the example you just saw, running `git checkout -b <branch> <remote>/<branch>`.
This is a common enough operation that Git provides the `--track` shorthand:

[source,console]
----
$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

In fact, this is so common that there's even a shortcut for that shortcut.
If the branch name you're trying to checkout (a) doesn't exist and (b) exactly matches a name on only one remote, Git will create a tracking branch for you:

[source,console]
----
$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch 'serverfix'
----

To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name:

[source,console]
----
$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch 'sf'
----

Now, your local branch `sf` will automatically pull from `origin/serverfix`.

If you already have a local branch and want to set it to a remote branch you just pulled down, or want to change the upstream branch you're tracking, you can use the `-u` or `--set-upstream-to` option to `git branch` to explicitly set it at any time.

[source,console]
----
$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
----

[NOTE]
.Upstream shorthand
====
When you have a tracking branch set up, you can reference its upstream branch with the `@{upstream}` or `@{u}` shorthand.
So if you're on the `master` branch and it's tracking `origin/master`, you can say something like `git merge @{u}` instead of `git merge origin/master` if you wish.(((+++@{u}+++)))(((+++@{upstream}+++)))
====

If you want to see what tracking branches you have set up, you can use the `-vv` option to `git branch`.
This will list out your local branches with more information including what each branch is tracking and if your local branch is ahead, behind or both.

[source,console]
----
$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
----

So here we can see that our `iss53` branch is tracking `origin/iss53` and is ``ahead'' by two, meaning that we have two commits locally that are not pushed to the server.
We can also see that our `master` branch is tracking `origin/master` and is up to date.
Next we can see that our `serverfix` branch is tracking the `server-fix-good` branch on our `teamone` server and is ahead by three and behind by one, meaning that there is one commit on the server we haven't merged in yet and three commits locally that we haven't pushed.
Finally we can see that our `testing` branch is not tracking any remote branch.

It's important to note that these numbers are only since the last time you fetched from each server.
This command does not reach out to the servers, it's telling you about what it has cached from these servers locally.
If you want totally up to date ahead and behind numbers, you'll need to fetch from all your remotes right before running this.
You could do that like this:

[source,console]
----
$ git fetch --all; git branch -vv
----

==== Pulling

(((pulling)))
While the `git fetch` command will fetch all the changes on the server that you don't have yet, it will not modify your working directory at all.
It will simply get the data for you and let you merge it yourself.
However, there is a command called `git pull` which is essentially a `git fetch` immediately followed by a `git merge` in most cases.
If you have a tracking branch set up as demonstrated in the last section, either by explicitly setting it or by having it created for you by the `clone` or `checkout` commands, `git pull` will look up what server and branch your current branch is tracking, fetch from that server and then try to merge in that remote branch.

Generally it's better to simply use the `fetch` and `merge` commands explicitly as the magic of `git pull` can often be confusing.

[[_delete_branches]]
==== Deleting Remote Branches

(((branches, deleting remote)))
Suppose you're done with a remote branch -- say you and your collaborators are finished with a feature and have merged it into your remote's `master` branch (or whatever branch your stable codeline is in).
You can delete a remote branch using the `--delete` option to `git push`.
If you want to delete your `serverfix` branch from the server, you run the following:

[source,console]
----
$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
----

Basically all this does is remove the pointer from the server.
The Git server will generally keep the data there for a while until a garbage collection runs, so if it was accidentally deleted, it's often easy to recover.
